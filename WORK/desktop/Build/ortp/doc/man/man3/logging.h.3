.TH "logging.h" 3 "Fri Dec 15 2017" "Version 1.0.2" "oRTP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
logging.h \- Logging API\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <ortp/port\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBORTP_LOG_DOMAIN\fP   NULL"
.br
.ti -1c
.RI "#define \fBortp_log_level_enabled\fP(domain,  level)   (ortp_get_log_level_mask(domain) & (level))"
.br
.ti -1c
.RI "#define \fBCHECK_FORMAT_ARGS\fP(m,  n)"
.br
.ti -1c
.RI "#define \fBortp_debug\fP(\&.\&.\&.)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBOrtpLogFunc\fP) (const char *domain, OrtpLogLevel lev, const char *fmt, va_list args)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBOrtpLogLevel\fP { \fBORTP_DEBUG\fP =1, \fBORTP_TRACE\fP =1<<1, \fBORTP_MESSAGE\fP =1<<2, \fBORTP_WARNING\fP =1<<3, \fBORTP_ERROR\fP =1<<4, \fBORTP_FATAL\fP =1<<5, \fBORTP_LOGLEV_END\fP =1<<6 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBortp_set_log_file\fP (FILE *file)"
.br
.ti -1c
.RI "void \fBortp_set_log_handler\fP (OrtpLogFunc func)"
.br
.ti -1c
.RI "OrtpLogFunc \fBortp_get_log_handler\fP (void)"
.br
.ti -1c
.RI "void \fBortp_logv_out\fP (const char *domain, OrtpLogLevel level, const char *fmt, va_list args)"
.br
.ti -1c
.RI "void \fBortp_logv\fP (const char *domain, OrtpLogLevel level, const char *fmt, va_list args)"
.br
.ti -1c
.RI "void \fBortp_logv_flush\fP (void)"
.br
.ti -1c
.RI "void \fBortp_set_log_level\fP (const char *domain, OrtpLogLevel level)"
.br
.ti -1c
.RI "void \fBortp_set_log_level_mask\fP (const char *domain, int levelmask)"
.br
.ti -1c
.RI "unsigned int \fBortp_get_log_level_mask\fP (const char *domain)"
.br
.ti -1c
.RI "void \fBortp_set_log_thread_id\fP (unsigned long thread_id)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Logging API\&. 


.SH "Function Documentation"
.PP 
.SS "void ortp_logv_flush (void)"
Flushes the log output queue\&. WARNING: Must be called from the thread that has been defined with \fBortp_set_log_thread_id()\fP\&. 
.SS "void ortp_set_log_file (FILE * file)"

.PP
\fBParameters:\fP
.RS 4
\fIfile\fP a FILE pointer where to output the ortp logs\&. 
.RE
.PP

.SS "void ortp_set_log_handler (OrtpLogFunc func)"

.PP
\fBParameters:\fP
.RS 4
\fIfunc\fP your logging function, compatible with the OrtpLogFunc prototype\&. 
.RE
.PP

.SS "void ortp_set_log_level (const char * domain, OrtpLogLevel level)"
Activate all log level greater or equal than specified level argument\&. 
.SS "void ortp_set_log_level_mask (const char * domain, int levelmask)"
@ param levelmask a mask of ORTP_DEBUG, ORTP_MESSAGE, ORTP_WARNING, ORTP_ERROR ORTP_FATAL \&. 
.SS "void ortp_set_log_thread_id (unsigned long thread_id)"
Tell oRTP the id of the thread used to output the logs\&. This is meant to output all the logs from the same thread to prevent deadlock problems at the application level\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread_id\fP The id of the thread that will output the logs (can be obtained using ortp_thread_self())\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for oRTP from the source code\&.
