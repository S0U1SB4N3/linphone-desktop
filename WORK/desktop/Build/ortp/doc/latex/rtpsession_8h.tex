\section{rtpsession.\+h File Reference}
\label{rtpsession_8h}\index{rtpsession.\+h@{rtpsession.\+h}}


The Rtp\+Session api.  


{\ttfamily \#include $<$bctoolbox/list.\+h$>$}\newline
{\ttfamily \#include $<$ortp/port.\+h$>$}\newline
{\ttfamily \#include $<$ortp/rtp.\+h$>$}\newline
{\ttfamily \#include $<$ortp/payloadtype.\+h$>$}\newline
{\ttfamily \#include $<$ortp/rtpprofile.\+h$>$}\newline
{\ttfamily \#include $<$ortp/sessionset.\+h$>$}\newline
{\ttfamily \#include $<$ortp/rtcp.\+h$>$}\newline
{\ttfamily \#include $<$ortp/str\+\_\+utils.\+h$>$}\newline
{\ttfamily \#include $<$ortp/utils.\+h$>$}\newline
{\ttfamily \#include $<$ortp/rtpsignaltable.\+h$>$}\newline
{\ttfamily \#include $<$ortp/event.\+h$>$}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ \+\_\+\+J\+B\+Parameters}
\item 
struct \textbf{ \+\_\+\+Jitter\+Control}
\item 
struct \textbf{ \+\_\+\+Wait\+Point}
\item 
struct \textbf{ \+\_\+\+Rtp\+Transport\+Modifier}
\item 
struct \textbf{ \+\_\+\+Rtp\+Transport}
\item 
struct \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Params}
\item 
struct \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Ctx}
\item 
struct \textbf{ Ortp\+Rtcp\+Send\+Algorithm}
\item 
struct \textbf{ Ortp\+Rtcp\+Fb\+Configuration}
\item 
struct \textbf{ Ortp\+Rtcp\+Xr\+Media\+Callbacks}
\item 
struct \textbf{ Ortp\+Rtcp\+Xr\+Configuration}
\item 
struct \textbf{ Ortp\+Rtcp\+Xr\+Stats}
\item 
struct \textbf{ Ortp\+Rtcp\+Tmmbr\+Info}
\item 
struct \textbf{ \+\_\+\+Ortp\+Address}
\item 
struct \textbf{ \+\_\+\+Ortp\+Stream}
\item 
struct \textbf{ \+\_\+\+Rtp\+Stream}
\item 
struct \textbf{ \+\_\+\+Rtcp\+Stream}
\item 
struct \textbf{ \+\_\+\+Rtp\+Session}
\item 
struct \textbf{ \+\_\+\+Ortp\+Video\+Bandwidth\+Estimator\+Params}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{rtpsession_8h_ae8364ff8d641437f64db26f0c5496fd6}} 
\#define {\bfseries O\+R\+T\+P\+\_\+\+A\+V\+P\+F\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+N\+O\+NE}~0
\item 
\mbox{\label{rtpsession_8h_ae84c26ce4d3e292b56f532f129de73b8}} 
\#define {\bfseries O\+R\+T\+P\+\_\+\+A\+V\+P\+F\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+T\+M\+M\+BR}~(1 $<$$<$ 0)
\item 
\mbox{\label{rtpsession_8h_a9992c56fe4dcd8471b74c0ed1634004a}} 
\#define {\bfseries O\+R\+T\+P\+\_\+\+A\+V\+P\+F\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+N\+A\+CK}~(1 $<$$<$ 1)
\item 
\mbox{\label{rtpsession_8h_a3c603af07cb968bf19eb45cd76c19c46}} 
\#define {\bfseries O\+R\+T\+P\+\_\+\+R\+T\+C\+P\+\_\+\+X\+R\+\_\+\+U\+N\+A\+V\+A\+I\+L\+A\+B\+L\+E\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER}~127
\item 
\mbox{\label{rtpsession_8h_aebafb54a8e5c89125e363d14c0e53c5c}} 
\#define {\bfseries rtp\+\_\+session\+\_\+remove\+\_\+contributing\+\_\+sources}~rtp\+\_\+session\+\_\+remove\+\_\+contributing\+\_\+source
\item 
\mbox{\label{rtpsession_8h_a5fd8198a7297a09a67e4d52851366bdf}} 
\#define {\bfseries rtp\+\_\+session\+\_\+set\+\_\+flag}(session,  flag)~(session)-\/$>$flags$\vert$=(flag)
\item 
\mbox{\label{rtpsession_8h_a86766b15b3f7cb3c4b17dd0e7767ad5c}} 
\#define {\bfseries rtp\+\_\+session\+\_\+unset\+\_\+flag}(session,  flag)~(session)-\/$>$flags\&=$\sim$(flag)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{rtpsession_8h_a5d583de241654202f1c13dd6bc408e7f}} 
typedef enum \+\_\+\+Ortp\+Jitter\+Buffer\+Algorithm {\bfseries Ortp\+Jitter\+Buffer\+Algorithm}
\item 
typedef struct \textbf{ \+\_\+\+J\+B\+Parameters} \textbf{ J\+B\+Parameters}
\item 
\mbox{\label{rtpsession_8h_a4205699e0555a63bd81af2586497c034}} 
typedef struct \textbf{ \+\_\+\+Jitter\+Control} {\bfseries Jitter\+Control}
\item 
\mbox{\label{rtpsession_8h_ae8610e15ff6f0d81dafb6aabc7509637}} 
typedef struct \textbf{ \+\_\+\+Wait\+Point} {\bfseries Wait\+Point}
\item 
\mbox{\label{rtpsession_8h_a05389c4cca8b4811572d204ec6fec7ff}} 
typedef struct \textbf{ \+\_\+\+Rtp\+Transport\+Modifier} {\bfseries Rtp\+Transport\+Modifier}
\item 
\mbox{\label{rtpsession_8h_ae11f0980998cf9047234a410493fb944}} 
typedef struct \textbf{ \+\_\+\+Rtp\+Transport} {\bfseries Rtp\+Transport}
\item 
\mbox{\label{rtpsession_8h_a9a6c6d3da3b206c1152e33ba1716234b}} 
typedef enum \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Mode} {\bfseries Ortp\+Network\+Simulator\+Mode}
\item 
typedef struct \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Params} \textbf{ Ortp\+Network\+Simulator\+Params}
\item 
\mbox{\label{rtpsession_8h_a066443a1af99e13facf1d79b5e7ee133}} 
typedef struct \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Ctx} {\bfseries Ortp\+Network\+Simulator\+Ctx}
\item 
\mbox{\label{rtpsession_8h_ae66ad710ff1c91bd13531ed86a7aeeb6}} 
typedef struct \textbf{ Ortp\+Rtcp\+Send\+Algorithm} {\bfseries Ortp\+Rtcp\+Send\+Algorithm}
\item 
\mbox{\label{rtpsession_8h_a2d7fffc1ea7fa20013cb39fd3a88f966}} 
typedef struct \textbf{ Ortp\+Rtcp\+Fb\+Configuration} {\bfseries Ortp\+Rtcp\+Fb\+Configuration}
\item 
\mbox{\label{rtpsession_8h_ac2b3ce787af33f53214360ca11376615}} 
typedef Ortp\+Rtcp\+Xr\+Plc\+Status($\ast$ {\bfseries Ortp\+Rtcp\+Xr\+Plc\+Callback}) (void $\ast$userdata)
\item 
\mbox{\label{rtpsession_8h_acd36b18c32e0b8cb1e0cb5a82f92ddba}} 
typedef int($\ast$ {\bfseries Ortp\+Rtcp\+Xr\+Signal\+Level\+Callback}) (void $\ast$userdata)
\item 
\mbox{\label{rtpsession_8h_a11cfa15d5b3bac4f681f3a2ba413f40e}} 
typedef int($\ast$ {\bfseries Ortp\+Rtcp\+Xr\+Noise\+Level\+Callback}) (void $\ast$userdata)
\item 
\mbox{\label{rtpsession_8h_a0cc2fb4837f42a3bcca55d98b084b6a7}} 
typedef float($\ast$ {\bfseries Ortp\+Rtcp\+Xr\+Average\+Quality\+Indicator\+Callback}) (void $\ast$userdata)
\item 
\mbox{\label{rtpsession_8h_ab6aa6a888bd003195ec57a109349953f}} 
typedef struct \textbf{ Ortp\+Rtcp\+Xr\+Media\+Callbacks} {\bfseries Ortp\+Rtcp\+Xr\+Media\+Callbacks}
\item 
\mbox{\label{rtpsession_8h_ae5cb7917c60ae450a91df9c41a82c702}} 
typedef struct \textbf{ Ortp\+Rtcp\+Xr\+Configuration} {\bfseries Ortp\+Rtcp\+Xr\+Configuration}
\item 
\mbox{\label{rtpsession_8h_a7be2ed141af095006d31738d2182ccd0}} 
typedef struct \textbf{ Ortp\+Rtcp\+Xr\+Stats} {\bfseries Ortp\+Rtcp\+Xr\+Stats}
\item 
\mbox{\label{rtpsession_8h_a7493e9e4a931bc01b2d0ac06d7bfa7eb}} 
typedef struct \textbf{ Ortp\+Rtcp\+Tmmbr\+Info} {\bfseries Ortp\+Rtcp\+Tmmbr\+Info}
\item 
\mbox{\label{rtpsession_8h_a7be819afd9ffa890ce08444d5de021d6}} 
typedef struct \textbf{ \+\_\+\+Ortp\+Address} {\bfseries Ortp\+Address}
\item 
\mbox{\label{rtpsession_8h_aff2383acf84601ad4aa3c56408297884}} 
typedef struct \textbf{ \+\_\+\+Ortp\+Stream} {\bfseries Ortp\+Stream}
\item 
\mbox{\label{rtpsession_8h_a25eecf17321ed86bb56493637aba3ca6}} 
typedef struct \textbf{ \+\_\+\+Rtp\+Stream} {\bfseries Rtp\+Stream}
\item 
\mbox{\label{rtpsession_8h_a38544b17566b8a97abd18f12e1060af4}} 
typedef struct \textbf{ \+\_\+\+Rtcp\+Stream} {\bfseries Rtcp\+Stream}
\item 
\mbox{\label{rtpsession_8h_a904e0759e2d9ec2f67f6c63dfd0dbb66}} 
typedef struct \textbf{ \+\_\+\+Rtp\+Session} {\bfseries Rtp\+Session}
\item 
typedef struct \textbf{ \+\_\+\+Ortp\+Video\+Bandwidth\+Estimator\+Params} \textbf{ Ortp\+Video\+Bandwidth\+Estimator\+Params}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{rtpsession_8h_a92b43c38e09e41102c74caf800ca283a}} 
enum {\bfseries Rtp\+Session\+Mode} \{ \newline
{\bfseries R\+T\+P\+\_\+\+S\+E\+S\+S\+I\+O\+N\+\_\+\+R\+E\+C\+V\+O\+N\+LY}, 
\newline
{\bfseries R\+T\+P\+\_\+\+S\+E\+S\+S\+I\+O\+N\+\_\+\+S\+E\+N\+D\+O\+N\+LY}, 
\newline
{\bfseries R\+T\+P\+\_\+\+S\+E\+S\+S\+I\+O\+N\+\_\+\+S\+E\+N\+D\+R\+E\+CV}
 \}
\item 
\mbox{\label{rtpsession_8h_a12dd602d0765ecba0632f34cbc74fe34}} 
enum {\bfseries \+\_\+\+Ortp\+Jitter\+Buffer\+Algorithm} \{ \newline
{\bfseries Ortp\+Jitter\+Buffer\+Basic}, 
\newline
{\bfseries Ortp\+Jitter\+Buffer\+Recursive\+Least\+Square}
 \}
\item 
enum \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Mode} \{ \newline
{\bfseries Ortp\+Network\+Simulator\+Invalid} =-\/1, 
\newline
\textbf{ Ortp\+Network\+Simulator\+Inbound}, 
\newline
\textbf{ Ortp\+Network\+Simulator\+Outbound}, 
\newline
\textbf{ Ortp\+Network\+Simulator\+Outbound\+Controlled}
 \}
\item 
\mbox{\label{rtpsession_8h_aafbd304f3047da14a071c499cfd5256a}} 
enum {\bfseries Ortp\+Rtcp\+Xr\+Plc\+Status} \{ \newline
{\bfseries Ortp\+Rtcp\+Xr\+No\+Plc}, 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Silence\+Plc}, 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Enhanced\+Plc}
 \}
\item 
\mbox{\label{rtpsession_8h_a17bf7ed5fadf0b2408163bcfc69051ff}} 
enum {\bfseries Ortp\+Rtcp\+Xr\+Rcvr\+Rtt\+Mode} \{ \newline
{\bfseries Ortp\+Rtcp\+Xr\+Rcvr\+Rtt\+None}, 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Rcvr\+Rtt\+All}, 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Rcvr\+Rtt\+Sender}
 \}
\item 
\mbox{\label{rtpsession_8h_a400fa760cf895f44e75a01127d9c0c8a}} 
enum {\bfseries Ortp\+Rtcp\+Xr\+Stat\+Summary\+Flag} \{ \newline
{\bfseries Ortp\+Rtcp\+Xr\+Stat\+Summary\+Loss} = (1 $<$$<$ 7), 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Stat\+Summary\+Dup} = (1 $<$$<$ 6), 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Stat\+Summary\+Jitt} = (1 $<$$<$ 5), 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Stat\+Summary\+T\+TL} = (1 $<$$<$ 3), 
\newline
{\bfseries Ortp\+Rtcp\+Xr\+Stat\+Summary\+HL} = (1 $<$$<$ 4)
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{rtpsession_8h_a95e0f8dec110a47af7ba63efd5bee51a}} 
const char $\ast$ {\bfseries ortp\+\_\+network\+\_\+simulator\+\_\+mode\+\_\+to\+\_\+string} (Ortp\+Network\+Simulator\+Mode mode)
\item 
\mbox{\label{rtpsession_8h_a740cbd01c5d0cfa2c1f353183ab95c14}} 
Ortp\+Network\+Simulator\+Mode {\bfseries ortp\+\_\+network\+\_\+simulator\+\_\+mode\+\_\+from\+\_\+string} (const char $\ast$str)
\item 
\textbf{ Rtp\+Session} $\ast$ \textbf{ rtp\+\_\+session\+\_\+new} (int mode)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode} (\textbf{ Rtp\+Session} $\ast$session, int yesno)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode} (\textbf{ Rtp\+Session} $\ast$session, int yesno)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+profile} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Rtp\+Profile} $\ast$profile)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Rtp\+Profile} $\ast$profile)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Rtp\+Profile} $\ast$profile)
\item 
\textbf{ Rtp\+Profile} $\ast$ \textbf{ rtp\+\_\+session\+\_\+get\+\_\+profile} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\textbf{ Rtp\+Profile} $\ast$ \textbf{ rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\textbf{ Rtp\+Profile} $\ast$ \textbf{ rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile} (\textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+signal\+\_\+connect} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$signal\+\_\+name, Rtp\+Callback cb, void $\ast$user\+\_\+data)
\item 
int \textbf{ rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$signal\+\_\+name, Rtp\+Callback cb)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+ssrc} (\textbf{ Rtp\+Session} $\ast$session, uint32\+\_\+t ssrc)
\item 
uint32\+\_\+t \textbf{ rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc} (\textbf{ Rtp\+Session} $\ast$session)
\item 
uint32\+\_\+t \textbf{ rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number} (\textbf{ Rtp\+Session} $\ast$session, uint16\+\_\+t seq)
\item 
uint16\+\_\+t \textbf{ rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number} (\textbf{ Rtp\+Session} $\ast$session)
\item 
uint32\+\_\+t \textbf{ rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number} (\textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a5137f504acf4536dfcd0f1e0e52f2abb}} 
void {\bfseries rtp\+\_\+session\+\_\+set\+\_\+duplication\+\_\+ratio} (\textbf{ Rtp\+Session} $\ast$session, float ratio)
\item 
\mbox{\label{rtpsession_8h_a53f1d5afe6db2314411155f1d677ab22}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+jitter\+\_\+buffer} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t enabled)
\item 
\mbox{\label{rtpsession_8h_a737717d728c4375643257bbe2aee3f06}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+jitter\+\_\+buffer\+\_\+enabled} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ac14fd747e1168852e98aa99f028157c7}} 
void {\bfseries rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+buffer\+\_\+params} (\textbf{ Rtp\+Session} $\ast$session, const \textbf{ J\+B\+Parameters} $\ast$par)
\item 
\mbox{\label{rtpsession_8h_a9841bac05956a611de77d3cf051e54fa}} 
void {\bfseries rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+buffer\+\_\+params} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ J\+B\+Parameters} $\ast$par)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset} (\textbf{ Rtp\+Session} $\ast$s, uint32\+\_\+t offset)
\item 
\mbox{\label{rtpsession_8h_a15b80ab2a68ca8f8f5a034d3553c3c01}} 
uint32\+\_\+t {\bfseries rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ts\+\_\+offset} (\textbf{ Rtp\+Session} $\ast$s)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation} (\textbf{ Rtp\+Session} $\ast$session, int milisec)
\item 
\mbox{\label{rtpsession_8h_a0eee0ea3d4a44e68d1aef90b4b9a35be}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+adaptive\+\_\+jitter\+\_\+compensation} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t val)
\item 
\mbox{\label{rtpsession_8h_ad27be6013ce94656180a58963800230c}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+adaptive\+\_\+jitter\+\_\+compensation\+\_\+enabled} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit} (\textbf{ Rtp\+Session} $\ast$session, int miliseconds)
\item 
\mbox{\label{rtpsession_8h_a51e6229104f299f0f56cbae29c13d4c8}} 
int {\bfseries rtp\+\_\+session\+\_\+join\+\_\+multicast\+\_\+group} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$ip)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$addr, int rtp\+\_\+port, int rtcp\+\_\+port)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a44bc2c89317400018d2c3a5e70e556f7}} 
int {\bfseries rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+rtcp\+\_\+port} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$rtp\+\_\+addr, int rtp\+\_\+port, const char $\ast$rtcp\+\_\+addr, int rtcp\+\_\+port)
\item 
\mbox{\label{rtpsession_8h_a223175cddd49111f4fb0bb7a01f8c67f}} 
int {\bfseries rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+and\+\_\+port} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$addr, int rtp\+\_\+port, int rtcp\+\_\+port)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$addr, int port)
\item 
int \textbf{ rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$rtp\+\_\+addr, int rtp\+\_\+port, const char $\ast$rtcp\+\_\+addr, int rtcp\+\_\+port)
\item 
\mbox{\label{rtpsession_8h_aea909385f7283407515f41739dc1104d}} 
void {\bfseries rtp\+\_\+session\+\_\+clear\+\_\+aux\+\_\+remote\+\_\+addr} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a719903156295f7132a5288430a04f1a2}} 
void {\bfseries rtp\+\_\+session\+\_\+set\+\_\+sockets} (\textbf{ Rtp\+Session} $\ast$session, int rtpfd, int rtcpfd)
\item 
\mbox{\label{rtpsession_8h_a38408c00b1fd3139562c402cb14996a1}} 
void {\bfseries rtp\+\_\+session\+\_\+get\+\_\+transports} (const \textbf{ Rtp\+Session} $\ast$session, \textbf{ Rtp\+Transport} $\ast$$\ast$rtptr, \textbf{ Rtp\+Transport} $\ast$$\ast$rtcptr)
\item 
\mbox{\label{rtpsession_8h_a892108d17986f589039510e01eb6d3c4}} 
ortp\+\_\+socket\+\_\+t {\bfseries rtp\+\_\+session\+\_\+get\+\_\+rtp\+\_\+socket} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ab7eb2d4933b2b390504d9d0e0bed8728}} 
ortp\+\_\+socket\+\_\+t {\bfseries rtp\+\_\+session\+\_\+get\+\_\+rtcp\+\_\+socket} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+refresh\+\_\+sockets} (\textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+dscp} (\textbf{ Rtp\+Session} $\ast$session, int dscp)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+dscp} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+pktinfo} (\textbf{ Rtp\+Session} $\ast$session, int activate)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl} (\textbf{ Rtp\+Session} $\ast$session, int ttl)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl} (\textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback} (\textbf{ Rtp\+Session} $\ast$session, int yesno)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback} (\textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type} (\textbf{ Rtp\+Session} $\ast$session, int paytype)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type} (\textbf{ Rtp\+Session} $\ast$session, int pt)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type} (\textbf{ Rtp\+Session} $\ast$session, int paytype)
\item 
int \textbf{ rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type} (\textbf{ Rtp\+Session} $\ast$session, int pt)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t yesno)
\item 
\mbox{\label{rtpsession_8h_a153192c45a6b2b2c476aed703f70b916}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+get\+\_\+symmetric\+\_\+rtp} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a7c32a9801c46b793baca459b6ec713a8}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+rtcp\+\_\+mux} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t yesno)
\item 
\mbox{\label{rtpsession_8h_aabaa7b49bdfdf9ee99cff8a6cd7db086}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+rtcp\+\_\+mux\+\_\+enabled} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t yesno)
\item 
void \textbf{ rtp\+\_\+session\+\_\+enable\+\_\+rtcp} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t yesno)
\item 
\mbox{\label{rtpsession_8h_a16c478d6e3d4f513e456bccd69a1082f}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+rtcp\+\_\+enabled} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval} (\textbf{ Rtp\+Session} $\ast$session, int value\+\_\+ms)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session, int target\+\_\+bandwidth)
\item 
\mbox{\label{rtpsession_8h_adf9262378f77b77421c4b4c4ae75f9f0}} 
int {\bfseries rtp\+\_\+session\+\_\+get\+\_\+target\+\_\+upload\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a93f044c3d2d5f7dca22f3ebe769c600f}} 
void {\bfseries rtp\+\_\+session\+\_\+configure\+\_\+rtcp\+\_\+xr} (\textbf{ Rtp\+Session} $\ast$session, const \textbf{ Ortp\+Rtcp\+Xr\+Configuration} $\ast$config)
\item 
\mbox{\label{rtpsession_8h_affd27cdbfa418adb79d0b88b1a9ec836}} 
void {\bfseries rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+xr\+\_\+media\+\_\+callbacks} (\textbf{ Rtp\+Session} $\ast$session, const \textbf{ Ortp\+Rtcp\+Xr\+Media\+Callbacks} $\ast$cbs)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold} (\textbf{ Rtp\+Session} $\ast$session, int numpackets)
\item 
\textbf{ mblk\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session, uint32\+\_\+t user\+\_\+ts)
\item 
\textbf{ mblk\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+create\+\_\+packet} (\textbf{ Rtp\+Session} $\ast$session, size\+\_\+t header\+\_\+size, const uint8\+\_\+t $\ast$payload, size\+\_\+t payload\+\_\+size)
\item 
\textbf{ mblk\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw} (const uint8\+\_\+t $\ast$packet, size\+\_\+t packet\+\_\+size)
\item 
\textbf{ mblk\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data} (\textbf{ Rtp\+Session} $\ast$session, uint8\+\_\+t $\ast$payload, size\+\_\+t payload\+\_\+size, void($\ast$freefn)(void $\ast$))
\item 
\textbf{ mblk\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place} (\textbf{ Rtp\+Session} $\ast$session, uint8\+\_\+t $\ast$buffer, size\+\_\+t size, void($\ast$freefn)(void $\ast$))
\item 
int \textbf{ rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ mblk\+\_\+t} $\ast$mp, uint32\+\_\+t userts)
\item 
\mbox{\label{rtpsession_8h_a113b53a11073f3a359e0457af62f8359}} 
int {\bfseries rtp\+\_\+session\+\_\+sendto} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t is\+\_\+rtp, \textbf{ mblk\+\_\+t} $\ast$m, int flags, const struct sockaddr $\ast$destaddr, socklen\+\_\+t destlen)
\item 
\mbox{\label{rtpsession_8h_a6b88f6e1667e04f101b68ed894fe709e}} 
int {\bfseries rtp\+\_\+session\+\_\+recvfrom} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t is\+\_\+rtp, \textbf{ mblk\+\_\+t} $\ast$m, int flags, struct sockaddr $\ast$from, socklen\+\_\+t $\ast$fromlen)
\item 
int \textbf{ rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session, uint8\+\_\+t $\ast$buffer, int len, uint32\+\_\+t ts, int $\ast$have\+\_\+more)
\item 
int \textbf{ rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session, const uint8\+\_\+t $\ast$buffer, int len, uint32\+\_\+t userts)
\item 
void \textbf{ rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Ortp\+Ev\+Queue} $\ast$q)
\item 
\mbox{\label{rtpsession_8h_ae0674378982feb12052698246c33975a}} 
void {\bfseries rtp\+\_\+session\+\_\+unregister\+\_\+event\+\_\+queue} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Ortp\+Ev\+Queue} $\ast$q)
\item 
\mbox{\label{rtpsession_8h_a7a528d80218d9f631ad7d4c9e09ad0f2}} 
float {\bfseries rtp\+\_\+session\+\_\+compute\+\_\+send\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ac3be64e8e8612650cd6aa743b3a7c7de}} 
float {\bfseries rtp\+\_\+session\+\_\+compute\+\_\+recv\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
float \textbf{ rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
float \textbf{ rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a0c771668afc88e079dee0c7818650152}} 
float {\bfseries rtp\+\_\+session\+\_\+get\+\_\+rtp\+\_\+send\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ac163964b7bd839693e73468652fa57ad}} 
float {\bfseries rtp\+\_\+session\+\_\+get\+\_\+rtp\+\_\+recv\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a4efb6e795497a6a04140430c6dcd5119}} 
float {\bfseries rtp\+\_\+session\+\_\+get\+\_\+rtcp\+\_\+send\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a5264e0802fd408b75ec6be2b3621b7c4}} 
float {\bfseries rtp\+\_\+session\+\_\+get\+\_\+rtcp\+\_\+recv\+\_\+bandwidth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a2a25c075beba28f0cd6288723ddc23a2}} 
float {\bfseries rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth\+\_\+smooth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a119c7c184b4a57f84e893a031c8ef7db}} 
float {\bfseries rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth\+\_\+smooth} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ad144ccb870f8cc6e71ce79c0af449360}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+\+A\+PP} (\textbf{ Rtp\+Session} $\ast$session, uint8\+\_\+t subtype, const char $\ast$name, const uint8\+\_\+t $\ast$data, int datalen)
\item 
int \textbf{ rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ mblk\+\_\+t} $\ast$m)
\item 
uint32\+\_\+t \textbf{ rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session)
\item 
uint32\+\_\+t \textbf{ rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+flush\+\_\+sockets} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+release\+\_\+sockets} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+resync} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+reset} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+destroy} (\textbf{ Rtp\+Session} $\ast$session)
\item 
const \textbf{ rtp\+\_\+stats\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+get\+\_\+stats} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
const \textbf{ jitter\+\_\+stats\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ad56607a94e7e1cd9de0c27887da2d4ff}} 
void {\bfseries rtp\+\_\+session\+\_\+reset\+\_\+stats} (\textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+data} (\textbf{ Rtp\+Session} $\ast$session, void $\ast$data)
\item 
void $\ast$ \textbf{ rtp\+\_\+session\+\_\+get\+\_\+data} (const \textbf{ Rtp\+Session} $\ast$session)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size} (\textbf{ Rtp\+Session} $\ast$session, int bufsize)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size} (\textbf{ Rtp\+Session} $\ast$session, unsigned int size)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size} (\textbf{ Rtp\+Session} $\ast$session, unsigned int size)
\item 
\mbox{\label{rtpsession_8h_a14d67f51640dc5b1b2dc9f8190ba6be8}} 
uint32\+\_\+t {\bfseries rtp\+\_\+session\+\_\+ts\+\_\+to\+\_\+time} (\textbf{ Rtp\+Session} $\ast$session, uint32\+\_\+t timestamp)
\item 
\mbox{\label{rtpsession_8h_a779ac93b168d91c5ff1bd34e4b2d14fc}} 
uint32\+\_\+t {\bfseries rtp\+\_\+session\+\_\+time\+\_\+to\+\_\+ts} (\textbf{ Rtp\+Session} $\ast$session, int millisecs)
\item 
\mbox{\label{rtpsession_8h_afa6eff1d91ef62095d72ee5ae1e94b4f}} 
void {\bfseries rtp\+\_\+session\+\_\+make\+\_\+time\+\_\+distorsion} (\textbf{ Rtp\+Session} $\ast$session, int milisec)
\item 
void \textbf{ rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$cname, const char $\ast$name, const char $\ast$email, const char $\ast$phone, const char $\ast$loc, const char $\ast$tool, const char $\ast$note)
\item 
\mbox{\label{rtpsession_8h_a47f106dc11924d1fc450ef3d4e779dc2}} 
void {\bfseries rtp\+\_\+session\+\_\+add\+\_\+contributing\+\_\+source} (\textbf{ Rtp\+Session} $\ast$session, uint32\+\_\+t csrc, const char $\ast$cname, const char $\ast$name, const char $\ast$email, const char $\ast$phone, const char $\ast$loc, const char $\ast$tool, const char $\ast$note)
\item 
\mbox{\label{rtpsession_8h_ae39cb832b2e6f1de0a1de798c0ee8c36}} 
void {\bfseries rtp\+\_\+session\+\_\+remove\+\_\+contributing\+\_\+source} (\textbf{ Rtp\+Session} $\ast$session, uint32\+\_\+t csrc)
\item 
\mbox{\label{rtpsession_8h_a4ccc0590bf95c5462684b4f4966f3d1f}} 
\textbf{ mblk\+\_\+t} $\ast$ {\bfseries rtp\+\_\+session\+\_\+create\+\_\+rtcp\+\_\+sdes\+\_\+packet} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t full)
\item 
void \textbf{ rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time} (\textbf{ Rtp\+Session} $\ast$session, struct timeval $\ast$tv)
\item 
int \textbf{ rtp\+\_\+session\+\_\+bye} (\textbf{ Rtp\+Session} $\ast$session, const char $\ast$reason)
\item 
\mbox{\label{rtpsession_8h_aabf8d1d279c4d49f4f1c2e1f88be9fb0}} 
int {\bfseries rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+send\+\_\+error\+\_\+code} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_abf9e8f33f854c809de4e1da6fbc5b136}} 
void {\bfseries rtp\+\_\+session\+\_\+clear\+\_\+send\+\_\+error\+\_\+code} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ab83505924d68ce43c4009c14a9d0c895}} 
int {\bfseries rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+error\+\_\+code} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a87cdf99c14f0062e2c990d593ce1f724}} 
void {\bfseries rtp\+\_\+session\+\_\+clear\+\_\+recv\+\_\+error\+\_\+code} (\textbf{ Rtp\+Session} $\ast$session)
\item 
float \textbf{ rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ac5e55fab989567c9eca1d6b17b8af573}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+network\+\_\+simulation} (\textbf{ Rtp\+Session} $\ast$session, const \textbf{ Ortp\+Network\+Simulator\+Params} $\ast$params)
\item 
\mbox{\label{rtpsession_8h_a0e3495afa7299c06b2a1ccc5c6cb79b8}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+congestion\+\_\+detection} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t enabled)
\item 
\mbox{\label{rtpsession_8h_a64886f5589fd45ea9fb8abeb0f30a183}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+video\+\_\+bandwidth\+\_\+estimator} (\textbf{ Rtp\+Session} $\ast$session, const \textbf{ Ortp\+Video\+Bandwidth\+Estimator\+Params} $\ast$params)
\item 
void \textbf{ rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value} (\textbf{ Rtp\+Session} $\ast$session, const int value)
\begin{DoxyCompactList}\small\item\em For {\bfseries test purpose only}, sets a constant lost packet value within {\bfseries all} R\+T\+CP output packets.~\newline
. \end{DoxyCompactList}\item 
void \textbf{ rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value} (\textbf{ Rtp\+Session} $\ast$session, const unsigned int value)
\begin{DoxyCompactList}\small\item\em For {\bfseries test purpose only}, sets a constant interarrival\+\_\+jitter value within {\bfseries all} R\+T\+CP output packets.~\newline
. \end{DoxyCompactList}\item 
void \textbf{ rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value} (\textbf{ Rtp\+Session} $\ast$session, const unsigned int value)
\begin{DoxyCompactList}\small\item\em For {\bfseries test purpose only}, simulates a constant R\+TT (Round Trip Time) value by setting the L\+SR field within {\bfseries all} returned R\+T\+CP output packets.~\newline
. \end{DoxyCompactList}\item 
\textbf{ mblk\+\_\+t} $\ast$ \textbf{ rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq} (\textbf{ Rtp\+Session} $\ast$session, const uint16\+\_\+t sequence\+\_\+number)
\item 
\mbox{\label{rtpsession_8h_ae80e2d3768c47fd68022beb5fcf0e758}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+xr\+\_\+rcvr\+\_\+rtt} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a8d8a180b35c71202eea370fc0894a4a1}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+xr\+\_\+dlrr} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ac3e9e0a90f5ffc58b0378356426b1b2c}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+xr\+\_\+stat\+\_\+summary} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_adf1be34ad7a558afeff52d207be33321}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+xr\+\_\+voip\+\_\+metrics} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a1a37b09e4fb57bd66432d312e9fc7fc4}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+avpf\+\_\+enabled} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a9c948cdb486950e76294612e7cc22d9a}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+avpf\+\_\+payload\+\_\+type\+\_\+feature\+\_\+enabled} (\textbf{ Rtp\+Session} $\ast$session, unsigned char feature)
\item 
\mbox{\label{rtpsession_8h_a816c887d5cafaf07a46cba23b7c780f2}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+avpf\+\_\+feature\+\_\+enabled} (\textbf{ Rtp\+Session} $\ast$session, unsigned char feature)
\item 
\mbox{\label{rtpsession_8h_ae7401f0cfb41963bfa67437643775494}} 
void {\bfseries rtp\+\_\+session\+\_\+enable\+\_\+avpf\+\_\+feature} (\textbf{ Rtp\+Session} $\ast$session, unsigned char feature, bool\+\_\+t enable)
\item 
\mbox{\label{rtpsession_8h_afd044ec49998fa5ae8589cc2f34a5c1b}} 
uint16\+\_\+t {\bfseries rtp\+\_\+session\+\_\+get\+\_\+avpf\+\_\+rr\+\_\+interval} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a4ea9f57bdf47b2a234a9a1f06c33f918}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+rtcp\+\_\+psfb\+\_\+scheduled} (\textbf{ Rtp\+Session} $\ast$session, rtcp\+\_\+psfb\+\_\+type\+\_\+t type)
\item 
\mbox{\label{rtpsession_8h_aacd2a7bba3d2c9775693f5333c2141a9}} 
bool\+\_\+t {\bfseries rtp\+\_\+session\+\_\+rtcp\+\_\+rtpfb\+\_\+scheduled} (\textbf{ Rtp\+Session} $\ast$session, rtcp\+\_\+rtpfb\+\_\+type\+\_\+t type)
\item 
\mbox{\label{rtpsession_8h_a11e2e32147fe1f0f788ab8c1f8d9339b}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+generic\+\_\+nack} (\textbf{ Rtp\+Session} $\ast$session, uint16\+\_\+t pid, uint16\+\_\+t blp)
\item 
\mbox{\label{rtpsession_8h_aaa5740d8884395e37fe96dbd56e6dbf6}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+pli} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_ac0b7130e33ef7a77b00d8b2088512f54}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+fir} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a6296778e09913382365c93922dce5b59}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+sli} (\textbf{ Rtp\+Session} $\ast$session, uint16\+\_\+t first, uint16\+\_\+t number, uint8\+\_\+t picture\+\_\+id)
\item 
\mbox{\label{rtpsession_8h_aba87a630bf7cf2582b79dc05892859e3}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+rpsi} (\textbf{ Rtp\+Session} $\ast$session, uint8\+\_\+t $\ast$bit\+\_\+string, uint16\+\_\+t bit\+\_\+string\+\_\+len)
\item 
\mbox{\label{rtpsession_8h_a5ed3381c51b2379d63abefbf040a8c63}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+tmmbr} (\textbf{ Rtp\+Session} $\ast$session, uint64\+\_\+t mxtbr)
\item 
\mbox{\label{rtpsession_8h_a3a5bb368582ad7f9e6a0deeb38cbea93}} 
void {\bfseries rtp\+\_\+session\+\_\+send\+\_\+rtcp\+\_\+fb\+\_\+tmmbn} (\textbf{ Rtp\+Session} $\ast$session, uint32\+\_\+t ssrc)
\item 
\mbox{\label{rtpsession_8h_ab5c640264c748ac30f7f3f8bcb272996}} 
void {\bfseries rtp\+\_\+session\+\_\+init} (\textbf{ Rtp\+Session} $\ast$session, int mode)
\item 
\mbox{\label{rtpsession_8h_a7020a16cd720d19e83f3888272bb4446}} 
void {\bfseries rtp\+\_\+session\+\_\+uninit} (\textbf{ Rtp\+Session} $\ast$session)
\item 
\mbox{\label{rtpsession_8h_a3fe42694f10c7a7eb90c49861f1bfe36}} 
void {\bfseries rtp\+\_\+session\+\_\+dispatch\+\_\+event} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Ortp\+Event} $\ast$ev)
\item 
\mbox{\label{rtpsession_8h_a8ea7b139a9508c429b02060743bc15fe}} 
void {\bfseries rtp\+\_\+session\+\_\+set\+\_\+reuseaddr} (\textbf{ Rtp\+Session} $\ast$session, bool\+\_\+t yes)
\item 
int \textbf{ meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send} (\textbf{ Rtp\+Transport} $\ast$t, \textbf{ Rtp\+Transport\+Modifier} $\ast$tpm, \textbf{ mblk\+\_\+t} $\ast$msg, int flags)
\item 
int \textbf{ meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to} (\textbf{ Rtp\+Transport} $\ast$t, \textbf{ Rtp\+Transport\+Modifier} $\ast$tpm, \textbf{ mblk\+\_\+t} $\ast$msg, int flags, const struct sockaddr $\ast$to, socklen\+\_\+t tolen)
\item 
int \textbf{ meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv} (\textbf{ Rtp\+Transport} $\ast$t, \textbf{ Rtp\+Transport\+Modifier} $\ast$tpm, \textbf{ mblk\+\_\+t} $\ast$msg, int flags)
\item 
\textbf{ Rtp\+Transport} $\ast$ \textbf{ meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint} (const \textbf{ Rtp\+Transport} $\ast$transport)
\item 
void \textbf{ meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint} (\textbf{ Rtp\+Transport} $\ast$transport, \textbf{ Rtp\+Transport} $\ast$endpoint)
\item 
\mbox{\label{rtpsession_8h_ac78d3bb065429050e0f04cb1c0dd6fc0}} 
void {\bfseries meta\+\_\+rtp\+\_\+transport\+\_\+destroy} (\textbf{ Rtp\+Transport} $\ast$tp)
\item 
\mbox{\label{rtpsession_8h_a7738f1505b0bbdb00ff5ded08fbfa109}} 
void {\bfseries meta\+\_\+rtp\+\_\+transport\+\_\+append\+\_\+modifier} (\textbf{ Rtp\+Transport} $\ast$tp, \textbf{ Rtp\+Transport\+Modifier} $\ast$tpm)
\item 
\mbox{\label{rtpsession_8h_aa0ec5a17ee6547c1ebb186fd85f48d37}} 
int {\bfseries rtp\+\_\+session\+\_\+splice} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Rtp\+Session} $\ast$to\+\_\+session)
\item 
\mbox{\label{rtpsession_8h_a2efc065b04c9a7bc4d546a5f3dfb3fe6}} 
int {\bfseries rtp\+\_\+session\+\_\+unsplice} (\textbf{ Rtp\+Session} $\ast$session, \textbf{ Rtp\+Session} $\ast$to\+\_\+session)
\item 
\mbox{\label{rtpsession_8h_af058ea32d1a7f9fd292807bc14ecc9d5}} 
bool\+\_\+t {\bfseries ortp\+\_\+stream\+\_\+is\+\_\+ipv6} (\textbf{ Ortp\+Stream} $\ast$os)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The Rtp\+Session api. 

The Rtp\+Session objects represent a R\+TP session\+: once it is configured with local and remote network addresses and a payload type is given, it let you send and recv a media stream. 

\subsection{Typedef Documentation}
\mbox{\label{rtpsession_8h_a045ce176ebe9323b1e7574e35c5fc777}} 
\index{rtpsession.\+h@{rtpsession.\+h}!J\+B\+Parameters@{J\+B\+Parameters}}
\index{J\+B\+Parameters@{J\+B\+Parameters}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{J\+B\+Parameters}
{\footnotesize\ttfamily typedef struct \textbf{ \+\_\+\+J\+B\+Parameters}  \textbf{ J\+B\+Parameters}}

Jitter buffer parameters \mbox{\label{rtpsession_8h_a7c436ea11700f00fc5f1ad8e70b2eb5b}} 
\index{rtpsession.\+h@{rtpsession.\+h}!Ortp\+Network\+Simulator\+Params@{Ortp\+Network\+Simulator\+Params}}
\index{Ortp\+Network\+Simulator\+Params@{Ortp\+Network\+Simulator\+Params}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{Ortp\+Network\+Simulator\+Params}
{\footnotesize\ttfamily typedef struct \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Params} \textbf{ Ortp\+Network\+Simulator\+Params}}

Structure describing the network simulator parameters \mbox{\label{rtpsession_8h_a490c543c4d74dd460cff143820eceffd}} 
\index{rtpsession.\+h@{rtpsession.\+h}!Ortp\+Video\+Bandwidth\+Estimator\+Params@{Ortp\+Video\+Bandwidth\+Estimator\+Params}}
\index{Ortp\+Video\+Bandwidth\+Estimator\+Params@{Ortp\+Video\+Bandwidth\+Estimator\+Params}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{Ortp\+Video\+Bandwidth\+Estimator\+Params}
{\footnotesize\ttfamily typedef struct \textbf{ \+\_\+\+Ortp\+Video\+Bandwidth\+Estimator\+Params}  \textbf{ Ortp\+Video\+Bandwidth\+Estimator\+Params}}

Structure describing the video bandwidth estimator parameters 

\subsection{Enumeration Type Documentation}
\mbox{\label{rtpsession_8h_a0caa396950b0b4e735801e37f6e740df}} 
\index{rtpsession.\+h@{rtpsession.\+h}!\+\_\+\+Ortp\+Network\+Simulator\+Mode@{\+\_\+\+Ortp\+Network\+Simulator\+Mode}}
\index{\+\_\+\+Ortp\+Network\+Simulator\+Mode@{\+\_\+\+Ortp\+Network\+Simulator\+Mode}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{\+\_\+\+Ortp\+Network\+Simulator\+Mode}
{\footnotesize\ttfamily enum \textbf{ \+\_\+\+Ortp\+Network\+Simulator\+Mode}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Ortp\+Network\+Simulator\+Inbound@{Ortp\+Network\+Simulator\+Inbound}!rtpsession.\+h@{rtpsession.\+h}}\index{rtpsession.\+h@{rtpsession.\+h}!Ortp\+Network\+Simulator\+Inbound@{Ortp\+Network\+Simulator\+Inbound}}}\mbox{\label{rtpsession_8h_a0caa396950b0b4e735801e37f6e740dfa10cfd43bab32e947b1ea8705e5eff04c}} 
Ortp\+Network\+Simulator\+Inbound&simulation is applied when receiving packets \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Ortp\+Network\+Simulator\+Outbound@{Ortp\+Network\+Simulator\+Outbound}!rtpsession.\+h@{rtpsession.\+h}}\index{rtpsession.\+h@{rtpsession.\+h}!Ortp\+Network\+Simulator\+Outbound@{Ortp\+Network\+Simulator\+Outbound}}}\mbox{\label{rtpsession_8h_a0caa396950b0b4e735801e37f6e740dfa5d6240d40c29de7bd17d7944d6cb5a02}} 
Ortp\+Network\+Simulator\+Outbound&simulation is applied to sent packets \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Ortp\+Network\+Simulator\+Outbound\+Controlled@{Ortp\+Network\+Simulator\+Outbound\+Controlled}!rtpsession.\+h@{rtpsession.\+h}}\index{rtpsession.\+h@{rtpsession.\+h}!Ortp\+Network\+Simulator\+Outbound\+Controlled@{Ortp\+Network\+Simulator\+Outbound\+Controlled}}}\mbox{\label{rtpsession_8h_a0caa396950b0b4e735801e37f6e740dfaba58c2b92f32b0d2bd064c255e5678fe}} 
Ortp\+Network\+Simulator\+Outbound\+Controlled&simulation is applied to sent packets according to sent timestamps set in the timestamps field of mblk\+\_\+t, which is defined only with -\/\+D\+O\+R\+T\+P\+\_\+\+T\+I\+M\+E\+S\+T\+A\+MP \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\label{rtpsession_8h_affa99429db7b4961bc4e20d719174bb8}} 
\index{rtpsession.\+h@{rtpsession.\+h}!meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint@{meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint}}
\index{meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint@{meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint()}
{\footnotesize\ttfamily \textbf{ Rtp\+Transport}$\ast$ meta\+\_\+rtp\+\_\+transport\+\_\+get\+\_\+endpoint (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Transport} $\ast$}]{transport }\end{DoxyParamCaption})}

get endpoint if any 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em transport} & Rtp\+Transport object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxyref{\+\_\+\+Rtp\+Transport}{p.}{struct__RtpTransport} 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a6224b506a1bd399d1018e6fd70770f83}} 
\index{rtpsession.\+h@{rtpsession.\+h}!meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv@{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv}}
\index{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv@{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv()}
{\footnotesize\ttfamily int meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+recv (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Transport} $\ast$}]{t,  }\item[{\textbf{ Rtp\+Transport\+Modifier} $\ast$}]{tpm,  }\item[{\textbf{ mblk\+\_\+t} $\ast$}]{msg,  }\item[{int}]{flags }\end{DoxyParamCaption})}

allow a modifier to inject a packet which will be treated by successive modifiers \mbox{\label{rtpsession_8h_a43dc94c576c74a6f6b31cd85ced843a4}} 
\index{rtpsession.\+h@{rtpsession.\+h}!meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send@{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send}}
\index{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send@{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send()}
{\footnotesize\ttfamily int meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Transport} $\ast$}]{t,  }\item[{\textbf{ Rtp\+Transport\+Modifier} $\ast$}]{tpm,  }\item[{\textbf{ mblk\+\_\+t} $\ast$}]{msg,  }\item[{int}]{flags }\end{DoxyParamCaption})}

allow a modifier to inject a packet which will be treated by successive modifiers \mbox{\label{rtpsession_8h_ad533ea463933174626a46ce880410157}} 
\index{rtpsession.\+h@{rtpsession.\+h}!meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to@{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to}}
\index{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to@{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to()}
{\footnotesize\ttfamily int meta\+\_\+rtp\+\_\+transport\+\_\+modifier\+\_\+inject\+\_\+packet\+\_\+to\+\_\+send\+\_\+to (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Transport} $\ast$}]{t,  }\item[{\textbf{ Rtp\+Transport\+Modifier} $\ast$}]{tpm,  }\item[{\textbf{ mblk\+\_\+t} $\ast$}]{msg,  }\item[{int}]{flags,  }\item[{const struct sockaddr $\ast$}]{to,  }\item[{socklen\+\_\+t}]{tolen }\end{DoxyParamCaption})}

allow a modifier to inject a packet which will be treated by successive modifiers \mbox{\label{rtpsession_8h_abe440d6ab13b45268749ae7ed62771f1}} 
\index{rtpsession.\+h@{rtpsession.\+h}!meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint@{meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint}}
\index{meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint@{meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint()}
{\footnotesize\ttfamily void meta\+\_\+rtp\+\_\+transport\+\_\+set\+\_\+endpoint (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Transport} $\ast$}]{transport,  }\item[{\textbf{ Rtp\+Transport} $\ast$}]{endpoint }\end{DoxyParamCaption})}

set endpoint 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em transport} & Rtp\+Transport object. \\
\hline
\mbox{\tt in}  & {\em endpoint} & Rtp\+Endpoint. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a99fd2d76a065db4293ba8d1d7e5db720}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full@{rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full}}
\index{rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full@{rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+add\+\_\+aux\+\_\+remote\+\_\+addr\+\_\+full (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{rtp\+\_\+addr,  }\item[{int}]{rtp\+\_\+port,  }\item[{const char $\ast$}]{rtcp\+\_\+addr,  }\item[{int}]{rtcp\+\_\+port }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+add\+\_\+remote\+\_\+aux\+\_\+addr\+\_\+full\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session freshly created. \\
\hline
{\em rtp\+\_\+addr} & a local IP address in the xxx.\+xxx.\+xxx.\+xxx form. \\
\hline
{\em rtp\+\_\+port} & a local rtp port. \\
\hline
{\em rtcp\+\_\+addr} & a local IP address in the xxx.\+xxx.\+xxx.\+xxx form. \\
\hline
{\em rtcp\+\_\+port} & a local rtcp port. \begin{DoxyVerb}    Add an auxiliary remote address for the rtp session, ie a destination address where rtp packet
    are sent.

    Returns: 0 on success.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_ab765af066dcadb624d76b1c9ede2643a}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+bye@{rtp\+\_\+session\+\_\+bye}}
\index{rtp\+\_\+session\+\_\+bye@{rtp\+\_\+session\+\_\+bye}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+bye()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+bye (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{reason }\end{DoxyParamCaption})}

Sends a R\+T\+CP bye packet. 
\begin{DoxyParams}{Parameters}
{\em session} & Rtp\+Session \\
\hline
{\em reason} & the reason phrase. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_abcdc6f7a3f81323b4f89e6a072b65477}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+create\+\_\+packet@{rtp\+\_\+session\+\_\+create\+\_\+packet}}
\index{rtp\+\_\+session\+\_\+create\+\_\+packet@{rtp\+\_\+session\+\_\+create\+\_\+packet}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+create\+\_\+packet()}
{\footnotesize\ttfamily \textbf{ mblk\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+create\+\_\+packet (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{size\+\_\+t}]{header\+\_\+size,  }\item[{const uint8\+\_\+t $\ast$}]{payload,  }\item[{size\+\_\+t}]{payload\+\_\+size }\end{DoxyParamCaption})}

Allocates a new rtp packet. In the header, ssrc and payload\+\_\+type according to the session\textquotesingle{}s context. Timestamp is not set, it will be set when the packet is going to be sent with \doxyref{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_afda0872c335c06a86a45ca4591a8b7ee}. Sequence number is initalized to previous sequence number sent + 1 If payload\+\_\+size is zero, thus an empty packet (just a R\+TP header) is returned.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em header\+\_\+size} & the rtp header size. For standart size (without extensions), it is R\+T\+P\+\_\+\+F\+I\+X\+E\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+S\+I\+ZE \\
\hline
{\em payload} & data to be copied into the rtp packet. \\
\hline
{\em payload\+\_\+size} & size of data carried by the rtp packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a rtp packet in a mblk\+\_\+t (message block) structure. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_aac85c2ae4bbed6e8ce6d5cdb9a086810}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place@{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place}}
\index{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place@{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place()}
{\footnotesize\ttfamily \textbf{ mblk\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+in\+\_\+place (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{uint8\+\_\+t $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void($\ast$)(void $\ast$)}]{freefn }\end{DoxyParamCaption})}

Creates a new rtp packet using the buffer given in arguments (no copy). In the header, ssrc and payload\+\_\+type according to the session\textquotesingle{}s context. Timestamp and seq number are not set, there will be set when the packet is going to be sent with \doxyref{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_afda0872c335c06a86a45ca4591a8b7ee}. {\itshape freefn} can be N\+U\+LL, in that case payload will be kept untouched.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em buffer} & a buffer that contains first just enough place to write a R\+TP header, then the data to send. \\
\hline
{\em size} & the size of the buffer \\
\hline
{\em freefn} & a function that will be called once the buffer is no more needed (the data has been sent). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a rtp packet in a mblk\+\_\+t (message block) structure. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a684815dccddf66e6f544e4283f0c134e}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw@{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw}}
\index{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw@{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw()}
{\footnotesize\ttfamily \textbf{ mblk\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+raw (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t $\ast$}]{packet,  }\item[{size\+\_\+t}]{packet\+\_\+size }\end{DoxyParamCaption})}

Create a packet already including headers \mbox{\label{rtpsession_8h_a4ac174ce6991e2864fe7faa771c01199}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data@{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data}}
\index{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data@{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data()}
{\footnotesize\ttfamily \textbf{ mblk\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+create\+\_\+packet\+\_\+with\+\_\+data (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{uint8\+\_\+t $\ast$}]{payload,  }\item[{size\+\_\+t}]{payload\+\_\+size,  }\item[{void($\ast$)(void $\ast$)}]{freefn }\end{DoxyParamCaption})}

Creates a new rtp packet using the given payload buffer (no copy). The header will be allocated separetely. In the header, ssrc and payload\+\_\+type according to the session\textquotesingle{}s context. Timestamp and seq number are not set, there will be set when the packet is going to be sent with \doxyref{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_afda0872c335c06a86a45ca4591a8b7ee}. o\+R\+TP will send this packet using libc\textquotesingle{}s sendmsg() (if this function is availlable!) so that there will be no packet concatenation involving copies to be done in user-\/space. {\itshape freefn} can be N\+U\+LL, in that case payload will be kept untouched.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em payload} & the data to be sent with this packet \\
\hline
{\em payload\+\_\+size} & size of data \\
\hline
{\em freefn} & a function that will be called when the payload buffer is no more needed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: a rtp packet in a mblk\+\_\+t (message block) structure. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a7efc76b8a4814d771634243707c2420b}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+destroy@{rtp\+\_\+session\+\_\+destroy}}
\index{rtp\+\_\+session\+\_\+destroy@{rtp\+\_\+session\+\_\+destroy}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+destroy()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+destroy (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Destroys a rtp session. All memory allocated for the Rtp\+Session is freed.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a89f9b413210262726be7674b7742ad44}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+enable\+\_\+rtcp@{rtp\+\_\+session\+\_\+enable\+\_\+rtcp}}
\index{rtp\+\_\+session\+\_\+enable\+\_\+rtcp@{rtp\+\_\+session\+\_\+enable\+\_\+rtcp}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+enable\+\_\+rtcp()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+enable\+\_\+rtcp (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{bool\+\_\+t}]{yesno }\end{DoxyParamCaption})}

By default o\+R\+TP automatically sends R\+T\+CP SR or RR packets. If yesno is set to F\+A\+L\+SE, the R\+T\+CP sending of packet is disabled. This functionality might be needed for some equipments that do not support R\+T\+CP, leading to a traffic of I\+C\+MP errors on the network. It can also be used to save bandwidth despite the R\+T\+CP bandwidth is actually and usually very very low. \mbox{\label{rtpsession_8h_a5acb23b3409eac50fbfa6bf74f12a388}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+flush\+\_\+sockets@{rtp\+\_\+session\+\_\+flush\+\_\+sockets}}
\index{rtp\+\_\+session\+\_\+flush\+\_\+sockets@{rtp\+\_\+session\+\_\+flush\+\_\+sockets}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+flush\+\_\+sockets()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+flush\+\_\+sockets (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+flush\+\_\+sockets\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session\\
\hline
\end{DoxyParams}
Flushes the sockets for all pending incoming packets. This can be usefull if you did not listen to the stream for a while and wishes to start to receive again. During the time no receive is made packets get bufferised into the internal kernel socket structure. \mbox{\label{rtpsession_8h_a8a7a1274f07648191be9937148b92c0a}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss@{rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss}}
\index{rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss@{rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+cum\+\_\+loss (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Returns the latest cumulative loss value computed \mbox{\label{rtpsession_8h_a52ba91bc2d1a8bbccf8a4f0e1888e9e7}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts@{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts}}
\index{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts@{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts()}
{\footnotesize\ttfamily uint32\+\_\+t rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+recv\+\_\+ts (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Same thing as \doxyref{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts()}{p.}{rtpsession_8h_a85014c21ef1be0f1c5faf32fcce8deea} except that it\textquotesingle{}s for an incoming stream. Works only on scheduled mode.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the theoritical that would have to be receive now. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a85014c21ef1be0f1c5faf32fcce8deea}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts@{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts}}
\index{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts@{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts()}
{\footnotesize\ttfamily uint32\+\_\+t rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

When the rtp session is scheduled and has started to send packets, this function computes the timestamp that matches to the present time. Using this function can be usefull when sending discontinuous streams. Some time can be elapsed between the end of a stream burst and the begin of a new stream burst, and the application may be not not aware of this elapsed time. In order to get a valid (current) timestamp to pass to \doxyref{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a3ed3f377bf06840f0e32c9b9a76bad10} or \doxyref{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_afda0872c335c06a86a45ca4591a8b7ee}, the application may use \doxyref{rtp\+\_\+session\+\_\+get\+\_\+current\+\_\+send\+\_\+ts()}{p.}{rtpsession_8h_a85014c21ef1be0f1c5faf32fcce8deea}.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the current send timestamp for the rtp session. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_ad411cc6b736570c7f962ff8f8b4d9909}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+data@{rtp\+\_\+session\+\_\+get\+\_\+data}}
\index{rtp\+\_\+session\+\_\+get\+\_\+data@{rtp\+\_\+session\+\_\+get\+\_\+data}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+data()}
{\footnotesize\ttfamily void$\ast$ rtp\+\_\+session\+\_\+get\+\_\+data (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the void pointer previously set using \doxyref{rtp\+\_\+session\+\_\+set\+\_\+data()}{p.}{rtpsession_8h_a96e580dd37e34bb360c869dff75fdd51} 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a6c2a87c9f363671f19529909b0d023c1}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+dscp@{rtp\+\_\+session\+\_\+get\+\_\+dscp}}
\index{rtp\+\_\+session\+\_\+get\+\_\+dscp@{rtp\+\_\+session\+\_\+get\+\_\+dscp}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+dscp()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+dscp (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+get\+\_\+dscp\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session\\
\hline
\end{DoxyParams}
Returns the D\+S\+CP (Differentiated Services Code Point) for outgoing R\+TP packets. \mbox{\label{rtpsession_8h_af8d5bfef2fe5c0f9a61e34fe335a16d6}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats@{rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats}}
\index{rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats@{rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats()}
{\footnotesize\ttfamily const \textbf{ jitter\+\_\+stats\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+get\+\_\+jitter\+\_\+stats (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Retrieves the session\textquotesingle{}s jitter specific statistics. \mbox{\label{rtpsession_8h_afb1c0953e5c8dbfb0f464b8c967b7778}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time@{rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time}}
\index{rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time@{rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+get\+\_\+last\+\_\+recv\+\_\+time (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{struct timeval $\ast$}]{tv }\end{DoxyParamCaption})}

Gets last time a valid R\+TP or R\+T\+CP packet was received. 
\begin{DoxyParams}{Parameters}
{\em session} & Rtp\+Session to get last receive time from. \\
\hline
{\em tv} & Pointer to struct timeval to fill. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a2f93a8a2ea1f132b412bf8b9e66886ac}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port@{rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port}}
\index{rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port@{rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+get\+\_\+local\+\_\+port\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session for which \doxyref{rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr()}{p.}{rtpsession_8h_a21370581ee33d3519cdb578b153f782c} or \doxyref{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr()}{p.}{rtpsession_8h_a5668f5b4f85e7188c9ede364beb610cd} has been called \begin{DoxyVerb}    This function can be useful to retrieve the local port that was randomly choosen by
    rtp_session_set_remote_addr() when rtp_session_set_local_addr() was not called.

    Returns: the local port used to listen for rtp packets, -1 if not set.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_af409cc95767678af59767224912e9bd9}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback@{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback}}
\index{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback@{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+loopback\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session\\
\hline
\end{DoxyParams}
Returns the multicast loopback state of rtp session (true or false). \mbox{\label{rtpsession_8h_a530f51392ebb4811f402371833bd117a}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl@{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl}}
\index{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl@{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+get\+\_\+multicast\+\_\+ttl\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session\\
\hline
\end{DoxyParams}
Returns the T\+TL (Time-\/\+To-\/\+Live) for outgoing multicast packets. \mbox{\label{rtpsession_8h_a6189df28500f7b32d5f5e278c89dcce3}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+profile@{rtp\+\_\+session\+\_\+get\+\_\+profile}}
\index{rtp\+\_\+session\+\_\+get\+\_\+profile@{rtp\+\_\+session\+\_\+get\+\_\+profile}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+profile()}
{\footnotesize\ttfamily \textbf{ Rtp\+Profile}$\ast$ rtp\+\_\+session\+\_\+get\+\_\+profile (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \begin{DoxyVerb}    DEPRECATED! Returns current send profile.
    Use rtp_session_get_send_profile() or rtp_session_get_recv_profile()\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a94cff96b50ea0758118dbd6f6d995afc}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number@{rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number}}
\index{rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number@{rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number()}
{\footnotesize\ttfamily uint32\+\_\+t rtp\+\_\+session\+\_\+get\+\_\+rcv\+\_\+ext\+\_\+seq\+\_\+number (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Returns the highest extended sequence number received. \mbox{\label{rtpsession_8h_a5ecb1657fcd72967d5ece7ae298ecc38}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth}}
\index{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth()}
{\footnotesize\ttfamily float rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+bandwidth (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Get last computed recv bandwidth. Computation must have been done with rtp\+\_\+session\+\_\+compute\+\_\+recv\+\_\+bandwidth() \mbox{\label{rtpsession_8h_a740572361056922a8f6c1c916aad1461}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type}}
\index{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+payload\+\_\+type (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the payload type currently used in incoming rtp packets 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_ab0a11cd312984518930c9f970a56ab75}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile}}
\index{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile()}
{\footnotesize\ttfamily \textbf{ Rtp\+Profile}$\ast$ rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+profile (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \begin{DoxyVerb}    Returns current receive profile.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_ae260f30eb162a0e4686502e3cfb532ef}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc}}
\index{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc@{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc()}
{\footnotesize\ttfamily uint32\+\_\+t rtp\+\_\+session\+\_\+get\+\_\+recv\+\_\+ssrc (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Get the S\+S\+RC for the incoming stream.

If no packets have been received yet, 0 is returned. \mbox{\label{rtpsession_8h_a3d716085a1e32064943a8ec6ed455089}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation@{rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation}}
\index{rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation@{rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation()}
{\footnotesize\ttfamily float rtp\+\_\+session\+\_\+get\+\_\+round\+\_\+trip\+\_\+propagation (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Returns the last known round trip propagation delay.

This value is known after successful R\+T\+CP SR or RR exchanged between a sender and a receiver. o\+R\+TP automatically takes care of sending SR or RR packets. You might want to call this function when you receive an R\+T\+CP event (see \doxyref{rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue()}{p.}{rtpsession_8h_a9d31ac30cac9a6367d958de31d8df288} ). This value might not be known\+: at the beginning when no R\+T\+CP packets have been exchanged yet, or simply because the rtcp channel is broken due to firewall problematics, or because the remote implementation does not support R\+T\+CP.

\begin{DoxyReturn}{Returns}
the round trip propagation time in seconds if known, -\/1 if unknown. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a13ea8d1aee0c9ecc90d7c2429203d165}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth}}
\index{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth()}
{\footnotesize\ttfamily float rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+bandwidth (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Get last computed send bandwidth. Computation must have been done with rtp\+\_\+session\+\_\+compute\+\_\+send\+\_\+bandwidth() \mbox{\label{rtpsession_8h_a2eaa2be31af31a67e4bcfdbbcdba3732}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type}}
\index{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+payload\+\_\+type (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the payload type currently used in outgoing rtp packets 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_afe768707f24ac69099de4f4f6b983ea6}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile}}
\index{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile()}
{\footnotesize\ttfamily \textbf{ Rtp\+Profile}$\ast$ rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+profile (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \begin{DoxyVerb}    Returns current send profile.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a6c1d392f73d408de69304543c1c7444a}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc}}
\index{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc@{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc()}
{\footnotesize\ttfamily uint32\+\_\+t rtp\+\_\+session\+\_\+get\+\_\+send\+\_\+ssrc (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Get the S\+S\+RC for the outgoing stream.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a9623b86923bace9f34956f3e0fd475b3}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number@{rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number}}
\index{rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number@{rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number()}
{\footnotesize\ttfamily uint16\+\_\+t rtp\+\_\+session\+\_\+get\+\_\+seq\+\_\+number (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Get the current sequence number for outgoing stream. \mbox{\label{rtpsession_8h_a8afa511af8abfa37b705dd964ad5e251}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+get\+\_\+stats@{rtp\+\_\+session\+\_\+get\+\_\+stats}}
\index{rtp\+\_\+session\+\_\+get\+\_\+stats@{rtp\+\_\+session\+\_\+get\+\_\+stats}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+get\+\_\+stats()}
{\footnotesize\ttfamily const \textbf{ rtp\+\_\+stats\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+get\+\_\+stats (\begin{DoxyParamCaption}\item[{const \textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Retrieve the session\textquotesingle{}s statistics. \mbox{\label{rtpsession_8h_a0fa068a78f69d25603baf8801cd352b7}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+new@{rtp\+\_\+session\+\_\+new}}
\index{rtp\+\_\+session\+\_\+new@{rtp\+\_\+session\+\_\+new}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+new()}
{\footnotesize\ttfamily \textbf{ Rtp\+Session}$\ast$ rtp\+\_\+session\+\_\+new (\begin{DoxyParamCaption}\item[{int}]{mode }\end{DoxyParamCaption})}

Creates a new rtp session. If the session is able to send data (R\+T\+P\+\_\+\+S\+E\+S\+S\+I\+O\+N\+\_\+\+S\+E\+N\+D\+O\+N\+LY or R\+T\+P\+\_\+\+S\+E\+S\+S\+I\+O\+N\+\_\+\+S\+E\+N\+D\+R\+E\+CV), then a random S\+S\+RC number is choosed for the outgoing stream. 
\begin{DoxyParams}{Parameters}
{\em mode} & One of the Rtp\+Session\+Mode flags.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly created rtp session. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_ab65a3a4fe6defea5e409db6f4313c33b}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq@{rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq}}
\index{rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq@{rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq()}
{\footnotesize\ttfamily \textbf{ mblk\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+pick\+\_\+with\+\_\+cseq (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const uint16\+\_\+t}]{sequence\+\_\+number }\end{DoxyParamCaption})}

Try to get an rtp packet presented as a mblk\+\_\+t structure from the rtp session at a given sequence number. This function is very usefull for codec with Forward error correction capabilities

This function returns the entire packet (with header).


\begin{DoxyItemize}
\item 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em sequence\+\_\+number} & a sequence number.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a rtp packet presented as a mblk\+\_\+t, or N\+U\+LL if not found. 
\end{DoxyReturn}

\end{DoxyItemize}\mbox{\label{rtpsession_8h_a2e325c908712601c051a7eedc59ca935}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts}}
\index{rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{uint8\+\_\+t $\ast$}]{buffer,  }\item[{int}]{len,  }\item[{uint32\+\_\+t}]{ts,  }\item[{int $\ast$}]{have\+\_\+more }\end{DoxyParamCaption})}

N\+O\+TE\+: use of this function is discouraged when sending payloads other than pcm/pcmu/pcma/adpcm types. \doxyref{rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a7df1261d3eeaf10d283ba4ac34e2388d} does better job.

Tries to read the bytes of the incoming rtp stream related to timestamp ts. In case where the user supplied buffer {\itshape buffer} is not large enough to get all the data related to timestamp ts, then $\ast$( have\+\_\+more) is set to 1 to indicate that the application should recall the function with the same timestamp to get more data.

When the rtp session is scheduled (see \doxyref{rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode()}{p.}{rtpsession_8h_a431c5b6dd2834bef90fef43bd643eb80} ), and the blocking mode is on (see \doxyref{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode()}{p.}{rtpsession_8h_a3160cbe78f10ac689845ed967b7cd974} ), then the calling thread is suspended until the timestamp given as argument expires, whatever a received packet fits the query or not.

Important note\+: it is clear that the application cannot know the timestamp of the first packet of the incoming stream, because it can be random. The {\itshape ts} timestamp given to the function is used relatively to first timestamp of the stream. In simple words, 0 is a good value to start calling this function.

This function internally calls \doxyref{rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a7df1261d3eeaf10d283ba4ac34e2388d} to get a rtp packet. The content of this packet is then copied into the user supplied buffer in an intelligent manner\+: the function takes care of the size of the supplied buffer and the timestamp given in argument. Using this function it is possible to read continous audio data (e.\+g. pcma,pcmu...) with for example a standart buffer of size of 160 with timestamp incrementing by 160 while the incoming stream has a different packet size.

Returns\+: if a packet was availlable with the corresponding timestamp supplied in argument then the number of bytes written in the user supplied buffer is returned. If no packets are availlable, either because the sender has not started to send the stream, or either because silence packet are not transmitted, or either because the packet was lost during network transport, then the function returns zero. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em buffer} & a user supplied buffer to write the data. \\
\hline
{\em len} & the length in bytes of the user supplied buffer. \\
\hline
{\em ts} & the timestamp wanted. \\
\hline
{\em have\+\_\+more} & the address of an integer to indicate if more data is availlable for the given timestamp. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a7df1261d3eeaf10d283ba4ac34e2388d}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts}}
\index{rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts()}
{\footnotesize\ttfamily \textbf{ mblk\+\_\+t}$\ast$ rtp\+\_\+session\+\_\+recvm\+\_\+with\+\_\+ts (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{uint32\+\_\+t}]{user\+\_\+ts }\end{DoxyParamCaption})}

Try to get a rtp packet presented as a mblk\+\_\+t structure from the rtp session. The {\itshape user\+\_\+ts} parameter is relative to the first timestamp of the incoming stream. In other words, the application does not have to know the first timestamp of the stream, it can simply call for the first time this function with {\itshape user\+\_\+ts=0}, and then incrementing it as it want. The Rtp\+Session takes care of synchronisation between the stream timestamp and the user timestamp given here.

This function returns the entire packet (with header).

The behaviour of this function has changed since version 0.\+15.\+0. Previously the payload data could be accessed using mblk\+\_\+t\+::b\+\_\+cont\+::b\+\_\+rptr field of the returned mblk\+\_\+t. This is no more the case. The convenient way of accessing the payload data is to use rtp\+\_\+get\+\_\+payload() \+: 
\begin{DoxyCode}
\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *payload;
\textcolor{keywordtype}{int} payload\_size;
payload\_size=rtp\_get\_payload(mp,&payload);
\end{DoxyCode}
 OR simply skip the header this way, the data is then comprised between mp-\/$>$b\+\_\+rptr and mp-\/$>$b\+\_\+wptr\+: 
\begin{DoxyCode}
rtp\_get\_payload(mp,&mp->b\_rptr);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em user\+\_\+ts} & a timestamp.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a rtp packet presented as a mblk\+\_\+t. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a56ce46e45420450b94a4d209c9030249}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+refresh\+\_\+sockets@{rtp\+\_\+session\+\_\+refresh\+\_\+sockets}}
\index{rtp\+\_\+session\+\_\+refresh\+\_\+sockets@{rtp\+\_\+session\+\_\+refresh\+\_\+sockets}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+refresh\+\_\+sockets()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+refresh\+\_\+sockets (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Requests the session to re-\/create and bind its R\+TP and R\+T\+CP sockets same as they are currently. This is used when a change in the routing rules of the host or process was made, in order to have this routing rules change taking effect on the R\+T\+P/\+R\+T\+CP packets sent by the session. \mbox{\label{rtpsession_8h_a9d31ac30cac9a6367d958de31d8df288}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue@{rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue}}
\index{rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue@{rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+register\+\_\+event\+\_\+queue (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{\textbf{ Ortp\+Ev\+Queue} $\ast$}]{q }\end{DoxyParamCaption})}

Register an event queue. An application can use an event queue to get informed about various R\+TP events. \mbox{\label{rtpsession_8h_a6e0cb1ebe665e66eb8696f5b0de64c2c}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+release\+\_\+sockets@{rtp\+\_\+session\+\_\+release\+\_\+sockets}}
\index{rtp\+\_\+session\+\_\+release\+\_\+sockets@{rtp\+\_\+session\+\_\+release\+\_\+sockets}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+release\+\_\+sockets()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+release\+\_\+sockets (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Closes the rtp and rtcp sockets, and associated Rtp\+Transport. \mbox{\label{rtpsession_8h_a87c96ff6a38bd0683165040af5ec1418}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+reset@{rtp\+\_\+session\+\_\+reset}}
\index{rtp\+\_\+session\+\_\+reset@{rtp\+\_\+session\+\_\+reset}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+reset()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+reset (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Reset the session\+: local and remote addresses are kept. It resets timestamp, sequence number, and calls \doxyref{rtp\+\_\+session\+\_\+resync()}{p.}{rtpsession_8h_addfadb13d0fbeefb59d1641b878c4c64}.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_addfadb13d0fbeefb59d1641b878c4c64}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+resync@{rtp\+\_\+session\+\_\+resync}}
\index{rtp\+\_\+session\+\_\+resync@{rtp\+\_\+session\+\_\+resync}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+resync()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+resync (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session }\end{DoxyParamCaption})}

Resynchronize to the incoming R\+TP streams. This can be useful to handle discontinuous timestamps. For example, call this function from the timestamp\+\_\+jump signal handler. 
\begin{DoxyParams}{Parameters}
{\em session} & the rtp session \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a9e09a51b0c29dba92d96dddb63b8a7c7}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw@{rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw}}
\index{rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw@{rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+rtcp\+\_\+sendm\+\_\+raw (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{\textbf{ mblk\+\_\+t} $\ast$}]{m }\end{DoxyParamCaption})}

Send the rtcp datagram {\itshape packet} to the destination set by \doxyref{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr()}{p.}{rtpsession_8h_a5668f5b4f85e7188c9ede364beb610cd} The packet ({\itshape packet}) is freed once it is sent.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em m} & a rtcp packet presented as a mblk\+\_\+t. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes sent over the network. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a0535400b3204ee190a2be6dcd983aa67}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value@{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value}}
\index{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value@{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+delay\+\_\+value (\begin{DoxyParamCaption}\item[{struct \textbf{ \+\_\+\+Rtp\+Session} $\ast$}]{s,  }\item[{const unsigned int}]{value }\end{DoxyParamCaption})}



For {\bfseries test purpose only}, simulates a constant R\+TT (Round Trip Time) value by setting the L\+SR field within {\bfseries all} returned R\+T\+CP output packets.~\newline
. 

The R\+TT processing involves two R\+T\+CP packets exchanged between two different devices.~\newline
In a {\bfseries normal} operation the device 1 issues a SR packets at time T0, hence this packet has a timestamp field set to T0. The L\+SR and D\+L\+SR fiels of that packet are not considered here. This packet is received by the Device 2 at T1. In response, the Device 2 issues another SR or RR packets at T2 with the following fields;
\begin{DoxyItemize}
\item a timestamp set to T2.
\item a L\+SR (Last SR packet timestamp) field set to T0 ( this value has been extracted from the first packet).
\item a D\+L\+SR (Delay since Last SR packet) field set to (T2 -\/ T1).
\end{DoxyItemize}This packet is received by The Device 1 at T3. So the Device 1 is now able to process the R\+TT using the formula \+: R\+TT = T3 -\/ L\+SR -\/ D\+L\+SR = (T1 -\/ T0) -\/ (T3 -\/ T2).~\newline
This way of processing is described in par. 6.\+4 of the R\+F\+C3550 standard.

In the {\bfseries test} mode that is enabled by this procedure, the R\+T\+CP stack is considered as beeing part of the device 2. For setting the R\+TT to a constant R\+T\+T0 value, the Device 2 artificially sets the L\+SR field of the second packet to (T1 -\/ R\+T\+T0), instead of T0 in normal mode. The two other fields (timestamp and D\+L\+SR) are set as in the normal mode. So the Device 1 will process \+: R\+TT = T3 -\/ L\+SR -\/ D\+L\+SR = R\+T\+T0 + (T3 -\/ T2) that is near to R\+T\+T0 is T3 -\/ T2 is small enough. \begin{DoxyNote}{Note}
It is impossible to actually make the mesured R\+TT strictly equal to R\+T\+T0, as the packet trip time (T3 -\/ T2) is unknown when this packet is issued by the Device 2. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em s} & \+: the rtp session. \\
\hline
{\em value} & \+: The desired R\+TT test vector value (R\+T\+T0). \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a163ae2018115d15813e3bfc8d2e32160}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value@{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value}}
\index{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value@{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+jitter\+\_\+value (\begin{DoxyParamCaption}\item[{struct \textbf{ \+\_\+\+Rtp\+Session} $\ast$}]{s,  }\item[{const unsigned int}]{value }\end{DoxyParamCaption})}



For {\bfseries test purpose only}, sets a constant interarrival\+\_\+jitter value within {\bfseries all} R\+T\+CP output packets.~\newline
. 

The SR or RR R\+T\+CP packet contain an interarrival jitter field. After this procedure is called, the interarrival jitter field will be set to a constant value in all output SR or RR packets. This parameter will overridden the actual interarrival jitter value that was processed by the R\+T\+CP stack. 
\begin{DoxyParams}{Parameters}
{\em s} & \+: the rtp session. \\
\hline
{\em value} & \+: the interarrival jitter test vector value. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a63a140410917d2afef8b62eb2f09ca3b}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value@{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value}}
\index{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value@{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+rtcp\+\_\+set\+\_\+lost\+\_\+packet\+\_\+value (\begin{DoxyParamCaption}\item[{struct \textbf{ \+\_\+\+Rtp\+Session} $\ast$}]{s,  }\item[{const int}]{value }\end{DoxyParamCaption})}



For {\bfseries test purpose only}, sets a constant lost packet value within {\bfseries all} R\+T\+CP output packets.~\newline
. 

The SR or RR R\+T\+CP packet contain a lost packet field. After this procedure is called, the lost packet field will be set to a constant value in all output SR or RR packets. This parameter will overridden the actual number of lost packets in the input R\+TP stream that the R\+T\+CP stack had previously processed. 
\begin{DoxyParams}{Parameters}
{\em s} & \+: the rtp session. \\
\hline
{\em value} & \+: the lost packets test vector value. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a3ed3f377bf06840f0e32c9b9a76bad10}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts}}
\index{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const uint8\+\_\+t $\ast$}]{buffer,  }\item[{int}]{len,  }\item[{uint32\+\_\+t}]{userts }\end{DoxyParamCaption})}

Send a rtp datagram to the destination set by \doxyref{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr()}{p.}{rtpsession_8h_a5668f5b4f85e7188c9ede364beb610cd} containing the data from {\itshape buffer} with timestamp {\itshape userts}. This is a high level function that uses \doxyref{rtp\+\_\+session\+\_\+create\+\_\+packet()}{p.}{rtpsession_8h_abcdc6f7a3f81323b4f89e6a072b65477} and \doxyref{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_afda0872c335c06a86a45ca4591a8b7ee} to send the data.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em buffer} & a buffer containing the data to be sent in a rtp packet. \\
\hline
{\em len} & the length of the data buffer, in bytes. \\
\hline
{\em userts} & the timestamp of the data to be sent. Refer to the rfc to know what it is. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes sent over the network. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_afda0872c335c06a86a45ca4591a8b7ee}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts}}
\index{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts@{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+sendm\+\_\+with\+\_\+ts (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{\textbf{ mblk\+\_\+t} $\ast$}]{packet,  }\item[{uint32\+\_\+t}]{timestamp }\end{DoxyParamCaption})}

Send the rtp datagram {\itshape packet} to the destination set by \doxyref{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr()}{p.}{rtpsession_8h_a5668f5b4f85e7188c9ede364beb610cd} with timestamp {\itshape timestamp}. For audio data, the timestamp is the number of the first sample resulting of the data transmitted. See rfc1889 for details. The packet ({\itshape packet}) is freed once it is sent.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em packet} & a rtp packet presented as a mblk\+\_\+t. \\
\hline
{\em timestamp} & the timestamp of the data to be sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes sent over the network. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a3160cbe78f10ac689845ed967b7cd974}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode@{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode}}
\index{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode@{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{yesno }\end{DoxyParamCaption})}

This function implicitely enables the scheduling mode if yesno is T\+R\+UE. \doxyref{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode()}{p.}{rtpsession_8h_a3160cbe78f10ac689845ed967b7cd974} defines the behaviour of the \doxyref{rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a2e325c908712601c051a7eedc59ca935} and \doxyref{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a3ed3f377bf06840f0e32c9b9a76bad10} functions. If {\itshape yesno} is T\+R\+UE, \doxyref{rtp\+\_\+session\+\_\+recv\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a2e325c908712601c051a7eedc59ca935} will block until it is time for the packet to be received, according to the timestamp passed to the function. After this time, the function returns. For \doxyref{rtp\+\_\+session\+\_\+send\+\_\+with\+\_\+ts()}{p.}{rtpsession_8h_a3ed3f377bf06840f0e32c9b9a76bad10}, it will block until it is time for the packet to be sent. If {\itshape yesno} is F\+A\+L\+SE, then the two functions will return immediately.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em yesno} & a boolean \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_af339d62b7aaa27764c549957da80a1d4}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode@{rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode}}
\index{rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode@{rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+connected\+\_\+mode (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{bool\+\_\+t}]{yesno }\end{DoxyParamCaption})}

If yesno is T\+R\+UE, thus a connect() syscall is done on the socket to the destination address set by \doxyref{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr()}{p.}{rtpsession_8h_a5668f5b4f85e7188c9ede364beb610cd}, or if the session does symmetric rtp (see \doxyref{rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp()}{p.}{rtpsession_8h_ab8988e3fe0655201ac244523a8245c9f}) a the connect() is done to the source address of the first packet received. Connecting a socket has effect of rejecting all incoming packets that don\textquotesingle{}t come from the address specified in connect(). It also makes I\+C\+MP errors (such as connection refused) available to the application. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em yesno} & a boolean to enable or disable the feature \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a96e580dd37e34bb360c869dff75fdd51}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+data@{rtp\+\_\+session\+\_\+set\+\_\+data}}
\index{rtp\+\_\+session\+\_\+set\+\_\+data@{rtp\+\_\+session\+\_\+set\+\_\+data}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+data()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+data (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}

Stores some application specific data into the session, so that it is easy to retrieve it from the signal callbacks using \doxyref{rtp\+\_\+session\+\_\+get\+\_\+data()}{p.}{rtpsession_8h_ad411cc6b736570c7f962ff8f8b4d9909}. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em data} & an opaque pointer to be stored in the session \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a6154b4d52a7b013413d81947f0891b17}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+dscp@{rtp\+\_\+session\+\_\+set\+\_\+dscp}}
\index{rtp\+\_\+session\+\_\+set\+\_\+dscp@{rtp\+\_\+session\+\_\+set\+\_\+dscp}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+dscp()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+dscp (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{dscp }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+set\+\_\+dscp\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em dscp} & desired D\+S\+CP P\+HB value\\
\hline
\end{DoxyParams}
Sets the D\+S\+CP (Differentiated Services Code Point) for outgoing R\+TP packets.

Returns\+: 0 on success. \mbox{\label{rtpsession_8h_a3504171811ed93af8630749aa4a1b881}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation@{rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation}}
\index{rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation@{rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+jitter\+\_\+compensation (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{milisec }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a Rtp\+Session \\
\hline
{\em milisec} & the time interval in milisec to be jitter compensed.\\
\hline
\end{DoxyParams}
Sets the time interval for which packet are buffered instead of being delivered to the application. \mbox{\label{rtpsession_8h_a21370581ee33d3519cdb578b153f782c}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr@{rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr}}
\index{rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr@{rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{addr,  }\item[{int}]{rtp\+\_\+port,  }\item[{int}]{rtcp\+\_\+port }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+set\+\_\+local\+\_\+addr\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session freshly created. \\
\hline
{\em addr} & a local IP address in the xxx.\+xxx.\+xxx.\+xxx form. \\
\hline
{\em rtp\+\_\+port} & a local port or -\/1 to let o\+R\+TP choose the port randomly \\
\hline
{\em rtcp\+\_\+port} & a local port or -\/1 to let o\+R\+TP choose the port randomly \begin{DoxyVerb}    Specify the local addr to be use to listen for rtp packets or to send rtp packet from.
    In case where the rtp session is send-only, then it is not required to call this function:
    when calling rtp_session_set_remote_addr(), if no local address has been set, then the
    default INADRR_ANY (0.0.0.0) IP address with a random port will be used. Calling
    rtp_session_set_local_addr() is mandatory when the session is recv-only or duplex.

    Returns: 0 on success.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a3ffa7ec566db9ed4f77263f47fafb005}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback@{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback}}
\index{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback@{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+loopback (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{yesno }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em yesno} & enable multicast loopback\\
\hline
\end{DoxyParams}
Enable multicast loopback.

Returns\+: 0 on success. \mbox{\label{rtpsession_8h_af7428b8772540474aa792897885c7af8}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl@{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl}}
\index{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl@{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{ttl }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+set\+\_\+multicast\+\_\+ttl\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em ttl} & desired Multicast Time-\/\+To-\/\+Live\\
\hline
\end{DoxyParams}
Sets the T\+TL (Time-\/\+To-\/\+Live) for outgoing multicast packets.

Returns\+: 0 on success. \mbox{\label{rtpsession_8h_a7056cfba3539095c6e4237b82c8bda94}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type}}
\index{rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+payload\+\_\+type (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{pt }\end{DoxyParamCaption})}

Sets the expected payload type for incoming packets and payload type to be used for outgoing packets. If the actual payload type in incoming packets is different that this expected payload type, thus the \char`\"{}payload\+\_\+type\+\_\+changed\char`\"{} signal is emitted.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em pt} & the payload type number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 if the payload is not defined. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a470b64302a541ddfd78d1e60e72de161}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+pktinfo@{rtp\+\_\+session\+\_\+set\+\_\+pktinfo}}
\index{rtp\+\_\+session\+\_\+set\+\_\+pktinfo@{rtp\+\_\+session\+\_\+set\+\_\+pktinfo}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+pktinfo()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+pktinfo (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{activate }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+set\+\_\+pktinfo\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em activate} & activation flag (0 to deactivate, other value to activate)\\
\hline
\end{DoxyParams}
(De)activates packet info for incoming and outgoing packets.

Returns\+: 0 on success. \mbox{\label{rtpsession_8h_a7f0a24e2969eb0b2abac2f1ad5a31002}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+profile@{rtp\+\_\+session\+\_\+set\+\_\+profile}}
\index{rtp\+\_\+session\+\_\+set\+\_\+profile@{rtp\+\_\+session\+\_\+set\+\_\+profile}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+profile()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+profile (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{\textbf{ Rtp\+Profile} $\ast$}]{profile }\end{DoxyParamCaption})}

Set the R\+TP profile to be used for the session. By default, all session are created by \doxyref{rtp\+\_\+session\+\_\+new()}{p.}{rtpsession_8h_a0fa068a78f69d25603baf8801cd352b7} are initialized with the AV profile, as defined in R\+FC 3551. The application can set any other profile instead using that function.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em profile} & a rtp profile \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_abf31386f3c893f7846341dfd2524368e}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size@{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size}}
\index{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size@{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+buf\+\_\+size (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{bufsize }\end{DoxyParamCaption})}

The default value is U\+D\+P\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE bytes, a value which is working for mostly everyone. However if your application can make assumption on the sizes of received packet, it can be interesting to set it to a lower value in order to save memory.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em bufsize} & max size in bytes for receiving packets \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a2cce98b970a30aa2c0b1b0714fb7ca6e}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type}}
\index{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+payload\+\_\+type (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{paytype }\end{DoxyParamCaption})}

Sets the expected payload type for incoming packets. If the actual payload type in incoming packets is different that this expected payload type, thus the \char`\"{}payload\+\_\+type\+\_\+changed\char`\"{} signal is emitted.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em paytype} & the payload type number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 if the payload is not defined. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_aff8d780e4e02d24ce7fd22a22b1b1448}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile@{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile}}
\index{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile@{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+recv\+\_\+profile (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{\textbf{ Rtp\+Profile} $\ast$}]{profile }\end{DoxyParamCaption})}

Set the R\+TP profile to be used for the receiveing by this session. By default, all session are created by \doxyref{rtp\+\_\+session\+\_\+new()}{p.}{rtpsession_8h_a0fa068a78f69d25603baf8801cd352b7} are initialized with the AV profile, as defined in R\+FC 3551. The application can set any other profile instead using that function.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em profile} & a rtp profile \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a5668f5b4f85e7188c9ede364beb610cd}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr@{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr}}
\index{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr@{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{addr,  }\item[{int}]{port }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session freshly created. \\
\hline
{\em addr} & a remote IP address in the xxx.\+xxx.\+xxx.\+xxx form. \\
\hline
{\em port} & a remote port. \begin{DoxyVerb}    Sets the remote address of the rtp session, ie the destination address where rtp packet
    are sent. If the session is recv-only or duplex, it also sets the origin of incoming RTP
    packets. Rtp packets that don't come from addr:port are discarded.

    Returns: 0 on success.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a2e567fa3141c55c14eea2d85f075db8d}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full@{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full}}
\index{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full@{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{rtp\+\_\+addr,  }\item[{int}]{rtp\+\_\+port,  }\item[{const char $\ast$}]{rtcp\+\_\+addr,  }\item[{int}]{rtcp\+\_\+port }\end{DoxyParamCaption})}

rtp\+\_\+session\+\_\+set\+\_\+remote\+\_\+addr\+\_\+full\+: 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session freshly created. \\
\hline
{\em rtp\+\_\+addr} & a remote IP address in the xxx.\+xxx.\+xxx.\+xxx form. \\
\hline
{\em rtp\+\_\+port} & a remote rtp port. \\
\hline
{\em rtcp\+\_\+addr} & a remote IP address in the xxx.\+xxx.\+xxx.\+xxx form. \\
\hline
{\em rtcp\+\_\+port} & a remote rtcp port. \begin{DoxyVerb}    Sets the remote address of the rtp session, ie the destination address where rtp packet
    are sent. If the session is recv-only or duplex, it also sets the origin of incoming RTP
    packets. Rtp packets that don't come from addr:port are discarded.

    Returns: 0 on success.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a9e6631e023727b61a6ceb78ab4a5918d}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval@{rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval}}
\index{rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval@{rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+rtcp\+\_\+report\+\_\+interval (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{value\+\_\+ms }\end{DoxyParamCaption})}

Sets the default interval in milliseconds for R\+T\+CP reports emitted by the session \mbox{\label{rtpsession_8h_a16d501a0be9f3748fff6e30c1f93e0aa}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size@{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size}}
\index{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size@{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+recv\+\_\+buffer\+\_\+size (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{unsigned int}]{size }\end{DoxyParamCaption})}

Set kernel recv maximum buffer size for the rtp socket. A value of zero defaults to the operating system default. \mbox{\label{rtpsession_8h_ae4a6c82c153319a4b390dde2a788da9e}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size@{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size}}
\index{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size@{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+rtp\+\_\+socket\+\_\+send\+\_\+buffer\+\_\+size (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{unsigned int}]{size }\end{DoxyParamCaption})}

Set kernel send maximum buffer size for the rtp socket. A value of zero defaults to the operating system default. \mbox{\label{rtpsession_8h_a431c5b6dd2834bef90fef43bd643eb80}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode@{rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode}}
\index{rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode@{rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+scheduling\+\_\+mode (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{yesno }\end{DoxyParamCaption})}

Sets the scheduling mode of the rtp session. If {\itshape yesno} is T\+R\+UE, the rtp session is in the scheduled mode, that means that you can use \doxyref{session\+\_\+set\+\_\+select()}{p.}{sessionset_8h_af199d48aa2a51ff81a772aef2c477e2e} to block until it\textquotesingle{}s time to receive or send on this session according to the timestamp passed to the respective functions. You can also use blocking mode (see \doxyref{rtp\+\_\+session\+\_\+set\+\_\+blocking\+\_\+mode()}{p.}{rtpsession_8h_a3160cbe78f10ac689845ed967b7cd974} ), to simply block within the receive and send functions. If {\itshape yesno} is F\+A\+L\+SE, the ortp scheduler will not manage those sessions, meaning that blocking mode and the use of \doxyref{session\+\_\+set\+\_\+select()}{p.}{sessionset_8h_af199d48aa2a51ff81a772aef2c477e2e} for this session are disabled. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em yesno} & a boolean to indicate the scheduling mode. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_ae894a47b51d8570930ebfae48e42fe1e}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type}}
\index{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+payload\+\_\+type (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{paytype }\end{DoxyParamCaption})}

Sets the payload type of the rtp session. It decides of the payload types written in the of the rtp header for the outgoing stream, if the session is S\+E\+N\+D\+R\+E\+CV or S\+E\+N\+D\+O\+N\+LY. For payload type in incoming packets, the application can be informed by registering for the \char`\"{}payload\+\_\+type\+\_\+changed\char`\"{} signal, so that it can make the necessary changes on the downstream decoder that deals with the payload of the packets.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em paytype} & the payload type number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 if the payload is not defined. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_aad82e403491b4e4696c1ebb1efe71f53}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile}}
\index{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+profile (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{\textbf{ Rtp\+Profile} $\ast$}]{profile }\end{DoxyParamCaption})}

Set the R\+TP profile to be used for the sending by this session. By default, all session are created by \doxyref{rtp\+\_\+session\+\_\+new()}{p.}{rtpsession_8h_a0fa068a78f69d25603baf8801cd352b7} are initialized with the AV profile, as defined in R\+FC 3551. The application can set any other profile instead using that function. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em profile} & a rtp profile \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_ad65db84a0d2bb28bbdbec30f9c12b2a3}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type}}
\index{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+telephone\+\_\+event\+\_\+payload\+\_\+type (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{paytype }\end{DoxyParamCaption})}

Assign the payload type number for sending telephone-\/event. It is required that a \char`\"{}telephone-\/event\char`\"{} Payload\+Type is assigned in the Rtp\+Profile set for the Rtp\+Session. This function is in most of cases useless, unless there is an ambiguity where several Payload\+Type for \char`\"{}telephone-\/event\char`\"{} are present in the Rtp\+Profile. This might happen during S\+IP offeranswer scenarios. This function allows to remove any ambiguity by letting the application choose the one to be used. 
\begin{DoxyParams}{Parameters}
{\em session} & the Rtp\+Session \\
\hline
{\em paytype} & the payload type number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0, -\/1 on error. 
\end{DoxyReturn}
\mbox{\label{rtpsession_8h_a3ba183096727b72225908e68ac4ed8c8}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset}}
\index{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset@{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+send\+\_\+ts\+\_\+offset (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{s,  }\item[{uint32\+\_\+t}]{offset }\end{DoxyParamCaption})}

Set an additional timestamps offset for outgoing stream.. 
\begin{DoxyParams}{Parameters}
{\em s} & a rtp session freshly created. \\
\hline
{\em offset} & a timestamp offset value \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_ac42dcb27e5976493da0d90de9bec5539}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number@{rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number}}
\index{rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number@{rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+seq\+\_\+number (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{uint16\+\_\+t}]{seq }\end{DoxyParamCaption})}

Set the initial sequence number for outgoing stream.. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session freshly created. \\
\hline
{\em seq} & a 16 bit unsigned number. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a05f1112dd80c82d3687f03529ca6550d}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description@{rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description}}
\index{rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description@{rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+source\+\_\+description (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{cname,  }\item[{const char $\ast$}]{name,  }\item[{const char $\ast$}]{email,  }\item[{const char $\ast$}]{phone,  }\item[{const char $\ast$}]{loc,  }\item[{const char $\ast$}]{tool,  }\item[{const char $\ast$}]{note }\end{DoxyParamCaption})}

Set session\textquotesingle{}s S\+D\+ES item for automatic sending of R\+T\+CP compound packets. If some items are not specified, use N\+U\+LL. \mbox{\label{rtpsession_8h_a3062539b7c2f064487511f6f0d8e216c}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+ssrc@{rtp\+\_\+session\+\_\+set\+\_\+ssrc}}
\index{rtp\+\_\+session\+\_\+set\+\_\+ssrc@{rtp\+\_\+session\+\_\+set\+\_\+ssrc}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+ssrc()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+ssrc (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{uint32\+\_\+t}]{ssrc }\end{DoxyParamCaption})}

Sets the S\+S\+RC for the outgoing stream. If not done, a random ssrc is used.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session. \\
\hline
{\em ssrc} & an unsigned 32bit integer representing the synchronisation source identifier (S\+S\+RC). \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a7e47523eeb130c48d79942a801e93f49}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold@{rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold}}
\index{rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold@{rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+ssrc\+\_\+changed\+\_\+threshold (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{numpackets }\end{DoxyParamCaption})}

Sets the number of packets containing a new S\+S\+RC that will trigger the \char`\"{}ssrc\+\_\+changed\char`\"{} callback. \mbox{\label{rtpsession_8h_ab8988e3fe0655201ac244523a8245c9f}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp@{rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp}}
\index{rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp@{rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+symmetric\+\_\+rtp (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{bool\+\_\+t}]{yesno }\end{DoxyParamCaption})}

Enable or disable the \char`\"{}rtp symmetric\char`\"{} hack which consists of the following\+: after the first packet is received, the source address of the packet is set to be the destination address for all next packets. This is useful to pass-\/through firewalls. 
\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em yesno} & a boolean to enable or disable the feature \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a4c291f9d3c9ab47108a126b8e277cb24}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth@{rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth}}
\index{rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth@{rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+target\+\_\+upload\+\_\+bandwidth (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{target\+\_\+bandwidth }\end{DoxyParamCaption})}

Define the bandwidth available for R\+T\+CP streams based on the upload bandwidth targeted by the application (in bits/s). R\+T\+CP streams would not take more than a few percents of the limit bandwidth (around 5\%).


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em target\+\_\+bandwidth} & bandwidth limit in bits/s \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_ae2d0b23dd9d14fdfe6ee4f4377b1a2f2}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit@{rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit}}
\index{rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit@{rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit()}
{\footnotesize\ttfamily void rtp\+\_\+session\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{int}]{milisecs }\end{DoxyParamCaption})}

o\+R\+TP has the possibility to inform the application through a callback registered with rtp\+\_\+session\+\_\+signal\+\_\+connect about crazy incoming R\+TP stream that jumps from a timestamp N to N+some\+\_\+crazy\+\_\+value. This lets the opportunity for the application to reset the session in order to resynchronize, or any other action like stopping the call and reporting an error. 
\begin{DoxyParams}{Parameters}
{\em session} & the rtp session \\
\hline
{\em milisecs} & a time interval in miliseconds \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_aa9f9421d7e744aa680d6fd327db29026}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+signal\+\_\+connect@{rtp\+\_\+session\+\_\+signal\+\_\+connect}}
\index{rtp\+\_\+session\+\_\+signal\+\_\+connect@{rtp\+\_\+session\+\_\+signal\+\_\+connect}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+signal\+\_\+connect()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+signal\+\_\+connect (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{signal\+\_\+name,  }\item[{Rtp\+Callback}]{cb,  }\item[{void $\ast$}]{user\+\_\+data }\end{DoxyParamCaption})}

This function provides the way for an application to be informed of various events that may occur during a rtp session. {\itshape signal\+\_\+name} is a string identifying the event, and {\itshape cb} is a user supplied function in charge of processing it. The application can register several callbacks for the same signal, in the limit of {\itshape R\+T\+P\+\_\+\+C\+A\+L\+L\+B\+A\+C\+K\+\_\+\+T\+A\+B\+L\+E\+\_\+\+M\+A\+X\+\_\+\+E\+N\+T\+R\+I\+ES}. Here are name and meaning of supported signals types\+:

\char`\"{}ssrc\+\_\+changed\char`\"{}\+: the S\+S\+RC of the incoming stream has changed.

\char`\"{}payload\+\_\+type\+\_\+changed\char`\"{}\+: the payload type of the incoming stream has changed.

\char`\"{}telephone-\/event\+\_\+packet\char`\"{}\+: a telephone-\/event rtp packet (R\+F\+C2833) is received.

\char`\"{}telephone-\/event\char`\"{}\+: a telephone event has occurred. This is a high-\/level shortcut for \char`\"{}telephone-\/event\+\_\+packet\char`\"{}.

\char`\"{}network\+\_\+error\char`\"{}\+: a network error happened on a socket. Arguments of the callback functions are a const char $\ast$ explaining the error, an int errno error code and the user\+\_\+data as usual.

\char`\"{}timestamp\+\_\+jump\char`\"{}\+: we have received a packet with timestamp in far future compared to last timestamp received. The farness of far future is set by rtp\+\_\+sesssion\+\_\+set\+\_\+time\+\_\+jump\+\_\+limit() \char`\"{}rtcp\+\_\+bye\char`\"{}\+: we have received a R\+T\+CP bye packet. Arguments of the callback functions are a const char $\ast$ containing the leaving reason and the user\+\_\+data. \char`\"{}congestion\+\_\+state\+\_\+changed\char`\"{}\+: congestion detector object changed its internal state. Arguments of the callback function are previous and new states. Returns\+: 0 on success, -\/\+E\+O\+P\+N\+O\+T\+S\+U\+PP if the signal does not exists, -\/1 if no more callbacks can be assigned to the signal type.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em signal\+\_\+name} & the name of a signal \\
\hline
{\em cb} & a Rtp\+Callback \\
\hline
{\em user\+\_\+data} & a pointer to any data to be passed when invoking the callback. \\
\hline
\end{DoxyParams}
\mbox{\label{rtpsession_8h_a3d02b773f1747f566c22a1f47eab96a1}} 
\index{rtpsession.\+h@{rtpsession.\+h}!rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback@{rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback}}
\index{rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback@{rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback}!rtpsession.\+h@{rtpsession.\+h}}
\subsubsection{rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback()}
{\footnotesize\ttfamily int rtp\+\_\+session\+\_\+signal\+\_\+disconnect\+\_\+by\+\_\+callback (\begin{DoxyParamCaption}\item[{\textbf{ Rtp\+Session} $\ast$}]{session,  }\item[{const char $\ast$}]{signal\+\_\+name,  }\item[{Rtp\+Callback}]{cb }\end{DoxyParamCaption})}

Removes callback function {\itshape cb} to the list of callbacks for signal {\itshape signal}.


\begin{DoxyParams}{Parameters}
{\em session} & a rtp session \\
\hline
{\em signal\+\_\+name} & a signal name \\
\hline
{\em cb} & a callback function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 0 on success, a negative value if the callback was not found. 
\end{DoxyReturn}
